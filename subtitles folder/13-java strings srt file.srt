1
00:00:06,560 --> 00:00:07,680
Okay.

2
00:00:07,680 --> 00:00:09,920
So let me try to.

3
00:00:11,840 --> 00:00:12,960
So last time

4
00:00:12,960 --> 00:00:16,760
we started discussing about the, um,

5
00:00:17,760 --> 00:00:20,560
string class.

6
00:00:21,360 --> 00:00:25,880
Well, why this string class is important
or what is this string class?

7
00:00:25,880 --> 00:00:29,240
Why we are even discussing it.

8
00:00:30,440 --> 00:00:32,840
How do I figure it out

9
00:00:32,840 --> 00:00:35,160
if they are trying

10
00:00:35,640 --> 00:00:37,480
to figure out this?

11
00:00:37,480 --> 00:00:40,200
And we did it. And there is a process.

12
00:00:40,200 --> 00:00:43,120
Um, it's called thinking.

13
00:00:44,120 --> 00:00:46,040
You have to think.

14
00:00:46,040 --> 00:00:48,720
And then you have to write the logic

15
00:00:49,640 --> 00:00:52,680
and been with loop or without the loop,

16
00:00:52,840 --> 00:00:55,920
you will be able to do it.

17
00:00:59,040 --> 00:01:03,440
Okay, So what is this, a string class?

18
00:01:03,960 --> 00:01:08,160
Thinking is hard.

19
00:01:08,160 --> 00:01:12,200
We can go step by step and break it down.

20
00:01:12,760 --> 00:01:17,120
And one more thing
some of you might not understand properly

21
00:01:17,640 --> 00:01:20,800
are all the cases about the prime numbers.

22
00:01:21,200 --> 00:01:23,400
Understanding how prime numbers work

23
00:01:24,720 --> 00:01:26,080
first and then try to.

24
00:01:26,080 --> 00:01:29,600
Logic will also help you a lot
if you understand what you are doing.

25
00:01:30,120 --> 00:01:32,960
You can easily break
that and break down that problem.

26
00:01:33,400 --> 00:01:37,200
And then you can write code for one

27
00:01:37,280 --> 00:01:40,400
or two steps at a time. Tested.

28
00:01:40,720 --> 00:01:42,320
And then write more.

29
00:01:42,320 --> 00:01:45,440
So understanding the problem
first is very important.

30
00:01:46,280 --> 00:01:51,960
As some of us,
we also make this mistake in the exams.

31
00:01:52,440 --> 00:01:55,440
Usually
we don't read the complete question

32
00:01:55,880 --> 00:01:59,960
or we fully don't understand,
and we just try to hide the answer

33
00:01:59,960 --> 00:02:02,920
and we lose a lot of marks
in the exams as well.

34
00:02:03,720 --> 00:02:07,560
So it's perfectly fine if you

35
00:02:07,760 --> 00:02:09,840
are reading it two times, three times,

36
00:02:09,840 --> 00:02:12,840
so that you can understand it easily

37
00:02:12,840 --> 00:02:17,400
and just know that
they cannot be divisible by any number

38
00:02:17,400 --> 00:02:18,600
other than yourself.

39
00:02:18,600 --> 00:02:21,280
No, there are more things to that.

40
00:02:21,280 --> 00:02:23,440
Negative numbers are not prime numbers

41
00:02:24,480 --> 00:02:26,400
is zero prime.

42
00:02:27,120 --> 00:02:29,240
They also start from the number one.

43
00:02:29,880 --> 00:02:32,520
So there are more and more education
that you need

44
00:02:32,520 --> 00:02:35,360
to fill it out.

45
00:02:40,120 --> 00:02:41,520
Okay, everyone,

46
00:02:41,880 --> 00:02:44,200
let's discuss it right.

47
00:02:44,200 --> 00:02:44,480
Yeah.

48
00:02:44,480 --> 00:02:47,200
Just make sure you try in the room
so that one no one sees.

49
00:02:48,000 --> 00:02:52,000
Are we allowed to go back to the exams
to use a quiz for family members

50
00:02:52,000 --> 00:02:53,800
to test on us with? You can.

51
00:02:53,800 --> 00:02:54,880
So what is this?

52
00:02:54,880 --> 00:02:56,400
A string class, everyone?

53
00:02:56,400 --> 00:02:58,960
Well, why do we use this string class?

54
00:02:59,000 --> 00:03:00,600
What does your test

55
00:03:12,000 --> 00:03:12,360
hold?

56
00:03:12,360 --> 00:03:14,280
A lot of data.

57
00:03:14,520 --> 00:04:23,240
What kind of data?

58
00:04:26,400 --> 00:04:28,440
So a string class

59
00:04:28,440 --> 00:04:34,320
is designed to score almost every symbol
that you see on a keyboard,

60
00:04:35,280 --> 00:04:38,400
whether it's a letters, alphabets, ABC,

61
00:04:39,640 --> 00:04:41,760
whether it's numbers

62
00:04:41,760 --> 00:04:46,080
1015, 20, whatever,
or whether they are special

63
00:04:46,080 --> 00:04:49,320
characters like dollar
sign, high sign, personal design.

64
00:04:50,280 --> 00:04:50,880
And in

65
00:04:50,880 --> 00:04:55,000
a string
you can store these symbols as a group.

66
00:04:55,440 --> 00:04:59,120
So string
classes are designed to store symbols

67
00:05:00,760 --> 00:05:04,200
in the form of a group.

68
00:05:05,360 --> 00:05:08,160
And if you focus

69
00:05:09,760 --> 00:05:10,600
carefully,

70
00:05:10,600 --> 00:05:14,560
most of the processing,
most of the calculations

71
00:05:15,040 --> 00:05:20,640
that are manipulations on the computers,
they are in the form of strings.

72
00:05:20,880 --> 00:05:21,800
Right.

73
00:05:21,840 --> 00:05:24,240
For example,
take the banking applications,

74
00:05:25,520 --> 00:05:28,640
everything your username, password, bank

75
00:05:28,640 --> 00:05:32,760
account, balance, details, everything
other than your picture.

76
00:05:32,760 --> 00:05:35,040
They they are stored
in the form of strings

77
00:05:35,680 --> 00:05:39,600
on Facebook, Amazon, everywhere
you see text.

78
00:05:39,880 --> 00:05:42,200
Most of the information around us

79
00:05:42,880 --> 00:05:45,400
is present in the form of text

80
00:05:46,720 --> 00:05:50,760
on your even the balance you can store
in the form of a string, but usually

81
00:05:50,760 --> 00:05:56,760
they are not stored in that form,
but it is capable of storing that as well.

82
00:05:57,360 --> 00:06:02,640
So because most of the information
in in real life around us

83
00:06:03,600 --> 00:06:06,720
these days, it's in in this form.

84
00:06:07,000 --> 00:06:10,000
That's why this string class

85
00:06:10,000 --> 00:06:12,120
is very important to understand.

86
00:06:13,160 --> 00:06:17,160
It's very important to understand
how to store this information.

87
00:06:18,080 --> 00:06:21,960
It's also very important to understand
how to manipulate this information.

88
00:06:22,720 --> 00:06:27,200
And because of this and this,
the same reason most of your interviews

89
00:06:27,600 --> 00:06:31,840
I mean, I have not seen any interview
hardly there were any questions

90
00:06:31,840 --> 00:06:37,200
or something in which this string class
was not involved in the interviews.

91
00:06:37,400 --> 00:06:41,920
Always loops, arrays, if conditions.

92
00:06:42,040 --> 00:06:43,560
And this string class is nothing else.

93
00:06:43,560 --> 00:06:44,720
When I draw down

94
00:06:45,200 --> 00:06:47,640
these are very important
for your coding question

95
00:06:47,640 --> 00:07:20,000
during interviews,
almost every interview question

96
00:07:20,000 --> 00:07:23,440
when I'm talking about
specifically the part where

97
00:07:24,000 --> 00:07:26,160
they will be asking you to write code.

98
00:07:26,880 --> 00:07:30,880
So there is one verbal part, 1
to 1 questions

99
00:07:30,960 --> 00:07:33,360
in which you have to answer verbally.

100
00:07:33,360 --> 00:07:36,640
And then there is this part

101
00:07:36,640 --> 00:07:40,320
in which you have to write
or they will be giving you a very small

102
00:07:42,520 --> 00:07:43,440
example.

103
00:07:43,440 --> 00:07:47,280
They will be asking you to solve
a very small problem or something,

104
00:07:47,880 --> 00:07:52,680
just like the problems that I have shared
with you in the coding questions.

105
00:07:52,680 --> 00:07:57,080
For example,
find the largest, smallest reverso string.

106
00:07:57,840 --> 00:07:59,920
How many characters are there
and things like that.

107
00:08:00,000 --> 00:08:03,360
Slowly,
once you see more examples and I routine,

108
00:08:04,400 --> 00:08:10,360
I will
I will keep on telling you the topics

109
00:08:10,360 --> 00:08:14,800
and for which part
they are very important.

110
00:08:14,800 --> 00:08:18,320
So from the topics
that we have covered already

111
00:08:20,240 --> 00:08:22,000
in the coding part

112
00:08:22,000 --> 00:08:24,640
where you have to write code,

113
00:08:24,960 --> 00:08:26,680
these are very important.

114
00:08:26,680 --> 00:08:29,080
You should be very good

115
00:08:31,560 --> 00:08:34,640
with these topics.

116
00:08:39,120 --> 00:08:42,440
So this string class is designed to store

117
00:08:42,440 --> 00:08:45,840
all of the numbers, letters, characters,
special characters in this format

118
00:08:46,320 --> 00:08:50,160
in the form of a group means
you can store to three four.

119
00:08:50,880 --> 00:08:54,040
There is a limit of 2.14 billion.

120
00:08:54,040 --> 00:08:58,840
This limit is same as the maximum number
that you can store inside an integer.

121
00:09:00,200 --> 00:09:00,760
Okay.

122
00:09:00,760 --> 00:09:05,120
Now not only string class helps us store
this information.

123
00:09:05,120 --> 00:09:09,040
There are so many matters
which are already written

124
00:09:09,960 --> 00:09:12,040
by Java developers

125
00:09:12,040 --> 00:09:15,960
that you can just use
to just write the name of the method

126
00:09:16,800 --> 00:09:21,960
and then it will process that string
and it will give you back the reserves.

127
00:09:21,960 --> 00:09:24,960
For example,

128
00:09:24,960 --> 00:09:28,520
we saw the Lent method, right?

129
00:09:28,560 --> 00:09:31,080
If we have a string stored
in a string variable,

130
00:09:31,320 --> 00:09:33,720
we simply call that length method.

131
00:09:33,720 --> 00:09:36,600
It automatically counts
how many characters

132
00:09:36,600 --> 00:09:39,480
we have stored inside of the string
and gives us the results.

133
00:09:40,280 --> 00:09:43,440
And we saw the other methods
uppercase, lowercase

134
00:09:43,520 --> 00:09:47,440
contains stocks for garnishment,
so these methods are already written.

135
00:09:47,440 --> 00:09:49,520
The logic is already written
by someone else.

136
00:09:50,440 --> 00:09:53,480
We just need to
know how to use these methods

137
00:09:55,000 --> 00:09:57,400
in so

138
00:09:58,200 --> 00:09:59,560
there are

139
00:10:00,240 --> 00:10:02,880
many methods

140
00:10:07,680 --> 00:10:11,640
already written

141
00:10:23,000 --> 00:10:27,000
by Java developers that you can

142
00:10:28,080 --> 00:10:29,880
just use.

143
00:10:29,880 --> 00:10:32,280
But if we want to use a method,

144
00:10:33,160 --> 00:10:35,640
we first need to understand

145
00:10:36,560 --> 00:10:40,560
what are methods,
how they are related to a class,

146
00:10:40,760 --> 00:10:43,920
how we call those matters
and how do we get results back.

147
00:10:44,960 --> 00:10:53,640
So for example,
these were some of the methods

148
00:10:53,640 --> 00:11:12,320
that we went to.

149
00:11:12,320 --> 00:11:13,080
Okay.

150
00:11:13,080 --> 00:11:16,120
So if you remember, can you tell me what
all this contains method?

151
00:11:16,120 --> 00:11:21,520
Do you

152
00:11:39,840 --> 00:11:42,480
so it searches

153
00:11:42,480 --> 00:11:46,120
if searches for the provided

154
00:11:47,440 --> 00:11:48,520
string,

155
00:11:49,200 --> 00:11:53,080
if it is present, it returns boolean true.

156
00:11:53,880 --> 00:12:04,320
If it is not present in that string,
it pretends to be false.

157
00:12:04,320 --> 00:12:06,880
Okay.

158
00:12:06,880 --> 00:12:09,880
There is one more important thing

159
00:12:12,280 --> 00:12:14,520
in this class.

160
00:12:15,000 --> 00:12:17,440
This is the most

161
00:12:19,120 --> 00:12:23,840
widely new class in Java

162
00:12:24,480 --> 00:12:27,080
and at this point there are around

163
00:12:27,160 --> 00:12:29,520
10,000 classes

164
00:12:30,280 --> 00:12:32,680
which are written
by Java developers for us.

165
00:12:33,120 --> 00:12:36,720
And then on top of that there are library
and frameworks and everything.

166
00:12:38,280 --> 00:12:40,520
And out of all those 10,000

167
00:12:40,520 --> 00:12:44,200
classes,
this is the most widely used class.

168
00:12:44,840 --> 00:12:48,320
So I hope you can understand
the importance of this class.

169
00:12:48,840 --> 00:12:52,640
Each and every method, each and every
concepts concept that I'm teaching you.

170
00:12:52,640 --> 00:12:54,600
It's very important.

171
00:12:55,040 --> 00:12:58,880
So please
make sure you understand it properly

172
00:13:06,040 --> 00:13:06,600
about it.

173
00:13:06,600 --> 00:13:08,960
Why we should

174
00:13:10,080 --> 00:13:12,440
learn about

175
00:13:14,280 --> 00:13:16,080
this class

176
00:13:20,120 --> 00:13:23,560
were very

177
00:13:23,560 --> 00:13:26,520
important for

178
00:13:27,240 --> 00:13:29,960
boring questions that we will be getting

179
00:13:32,120 --> 00:13:35,640
most widely

180
00:13:36,000 --> 00:13:38,080
used class an all

181
00:13:39,920 --> 00:13:41,480
new java

182
00:13:50,840 --> 00:13:52,880
and then

183
00:13:54,840 --> 00:13:58,800
most of the information

184
00:13:59,640 --> 00:14:02,520
and real life

185
00:14:03,240 --> 00:14:06,880
meanings is an

186
00:14:11,440 --> 00:14:13,640
all strings.

187
00:14:13,640 --> 00:14:16,320
Also, there is one more thing.

188
00:14:16,320 --> 00:14:18,600
Half of my brain is not working today.

189
00:14:19,120 --> 00:14:22,680
It will start working
maybe on a monday or Tuesday.

190
00:14:23,400 --> 00:14:27,800
So if I'm saying something different
and I am writing something different

191
00:14:28,280 --> 00:14:30,920
and I am meaning
something totally different,

192
00:14:31,880 --> 00:14:34,040
please, you should all order.

193
00:14:34,040 --> 00:14:41,240
The user would understand it by default
for the next two days.

194
00:14:41,240 --> 00:14:41,560
Yeah.

195
00:14:41,800 --> 00:14:46,800
Usually when I get this flu
and severe fever and everything in my mind

196
00:14:46,800 --> 00:15:07,880
brain does not work properly,
thank goodness.

197
00:15:08,160 --> 00:15:12,120
Okay,
so I hope you everyone now have an idea.

198
00:15:12,120 --> 00:15:13,960
What is this strain?

199
00:15:13,960 --> 00:15:15,920
Why we are learning it? Why?

200
00:15:15,920 --> 00:15:18,840
Why it's important

201
00:15:18,840 --> 00:15:21,120
where we will be using you turn everything

202
00:15:21,480 --> 00:15:24,880
I have taken on this and by the way,
it helped me a lot this time.

203
00:15:25,120 --> 00:15:27,480
Usually previously

204
00:15:27,480 --> 00:15:31,640
it used to take around
seven days for me to fully recover,

205
00:15:32,120 --> 00:15:35,040
but this time it was quick

206
00:15:39,400 --> 00:15:40,720
lemons and

207
00:15:41,280 --> 00:15:43,880
it's very helpful.

208
00:15:43,880 --> 00:15:46,160
Okay, so now we will continue

209
00:15:46,160 --> 00:15:49,320
to learn more methods
from this training class.

210
00:15:49,320 --> 00:15:54,720
And starting from today on these matters,
they get a little bit technical

211
00:15:55,200 --> 00:15:59,640
because we will be passing the information
inside these matters.

212
00:16:00,960 --> 00:16:02,440
Then they will be processing it

213
00:16:02,440 --> 00:16:06,280
and then will be returning us to results

214
00:16:15,160 --> 00:16:15,600
here.

215
00:16:15,880 --> 00:16:23,960
It is very good.

216
00:16:23,960 --> 00:16:26,120
I'll I'll get here doing so.

217
00:16:26,120 --> 00:16:28,680
Let's say we have a stream now.

218
00:16:28,680 --> 00:16:31,800
I am calling it SDR for short

219
00:16:32,640 --> 00:16:36,040
and to see

220
00:16:37,560 --> 00:16:41,840
I'm writing something like this.

221
00:16:41,840 --> 00:16:46,280
So this streaming, it contains a lot of

222
00:16:47,800 --> 00:16:49,680
characters, right?

223
00:16:49,680 --> 00:16:51,680
And you remember the range?

224
00:16:52,440 --> 00:16:54,760
Sorry, the ad is

225
00:16:56,920 --> 00:17:02,640
they were in that structure that can store

226
00:17:02,760 --> 00:17:07,040
multiple items in the same variable.

227
00:17:07,600 --> 00:17:09,720
And when we have to access the items,

228
00:17:10,720 --> 00:17:13,640
we can simply use the index

229
00:17:15,720 --> 00:17:17,920
and then we can access those items.

230
00:17:17,920 --> 00:17:20,880
So if you remember,
everything was given a number,

231
00:17:21,440 --> 00:17:25,800
the number we call as ADI.

232
00:17:25,800 --> 00:17:31,040
Do you think here also we can use an ADI
or maybe

233
00:17:31,520 --> 00:17:34,800
Java developers behind the scenes?

234
00:17:34,800 --> 00:17:38,600
Have we used an array to store
all of these letters?

235
00:17:38,600 --> 00:17:39,080
What do you think?

236
00:17:39,080 --> 00:17:48,360
Is it possible?

237
00:17:48,360 --> 00:17:50,280
Exactly.

238
00:17:50,280 --> 00:17:53,320
So Java developers also behind

239
00:17:53,320 --> 00:17:58,000
the scenes, they use

240
00:17:59,440 --> 00:18:02,200
an ADI

241
00:18:03,320 --> 00:18:06,080
to store all of these letters.

242
00:18:07,320 --> 00:18:09,800
And if they are using an array,
let me also show you

243
00:18:13,280 --> 00:18:13,920
artist find.

244
00:18:13,920 --> 00:18:16,840
It will not make much sense.

245
00:18:17,160 --> 00:18:18,920
But let me quickly show you.

246
00:18:18,920 --> 00:18:20,520
I have four.

247
00:18:20,520 --> 00:18:24,080
I'm holding down my control
and then clicking on this string class

248
00:18:25,200 --> 00:18:27,480
look, okay, don't worry

249
00:18:27,480 --> 00:18:29,760
about this private final byte

250
00:18:30,960 --> 00:18:34,360
focus on on this part byte value.

251
00:18:36,240 --> 00:18:38,440
And actually, this is not the one

252
00:18:38,440 --> 00:18:39,520
in which we

253
00:19:01,400 --> 00:19:02,360
solve behind the scenes.

254
00:19:02,360 --> 00:19:07,360
There is an area that holds the hold
all of the characters.

255
00:19:08,120 --> 00:19:10,680
So if there is an area

256
00:19:11,840 --> 00:19:14,520
that is holding this data

257
00:19:14,520 --> 00:19:16,920
format gives come on,

258
00:19:16,920 --> 00:19:19,040
that means this will make it

259
00:19:19,040 --> 00:19:24,040
a little bigger.

260
00:19:24,040 --> 00:19:26,400
If there is an array behind the scenes,

261
00:19:27,080 --> 00:19:30,960
that means this B is present at index
zero.

262
00:19:30,960 --> 00:19:34,320
Is that one, the two

263
00:19:35,320 --> 00:19:37,320
three or

264
00:19:37,320 --> 00:19:41,760
the spacing there at five
is six seven, Right.

265
00:19:42,000 --> 00:19:47,960
And then we can keep on going like this.

266
00:19:47,960 --> 00:19:49,800
Now tell me, everyone.

267
00:19:50,320 --> 00:19:53,480
Oh, by the way, in this string class,

268
00:19:54,400 --> 00:19:56,600
things are neutral, different

269
00:19:57,120 --> 00:20:00,000
than how things work with areas.

270
00:20:00,000 --> 00:20:04,800
For example,

271
00:20:04,800 --> 00:20:07,000
if you say SDR

272
00:20:07,920 --> 00:20:10,920
and then if you're trying to write

273
00:20:10,920 --> 00:20:13,320
this zero here, just like

274
00:20:13,320 --> 00:20:17,200
we used to do with arrays,
you will get an error.

275
00:20:17,920 --> 00:20:22,040
So this is syntax
because there is a class.

276
00:20:22,040 --> 00:20:25,560
This is not going to work here.

277
00:20:25,560 --> 00:20:29,280
It will only work when you create

278
00:20:29,680 --> 00:20:32,880
added yourself here.

279
00:20:32,880 --> 00:20:34,600
If you want to access any element

280
00:20:34,600 --> 00:20:36,720
from this, you have to use a method.

281
00:20:37,920 --> 00:20:41,040
So let me clear one thing in Java

282
00:20:42,360 --> 00:20:43,600
almost everything.

283
00:20:43,600 --> 00:20:46,920
99.99% things.

284
00:20:48,280 --> 00:20:50,280
They are classes

285
00:20:50,920 --> 00:20:52,160
and these classes

286
00:20:59,040 --> 00:21:02,040
they have methods.

287
00:21:02,040 --> 00:21:29,120
And whenever we want to implement.

288
00:21:29,120 --> 00:21:29,560
Sorry.

289
00:21:29,760 --> 00:21:34,040
So whenever we have to do any manipulation
or when

290
00:21:34,160 --> 00:21:36,800
whenever
we have to access something or something,

291
00:21:38,280 --> 00:21:41,840
we use methods for example.

292
00:21:42,360 --> 00:21:46,920
Yes. To get a stored in the form
of an array behind the scenes.

293
00:21:47,280 --> 00:21:51,800
But if we want to access,

294
00:21:51,800 --> 00:21:54,560
we have to use a method and the method is

295
00:21:56,080 --> 00:22:01,600
called char at.

296
00:22:01,600 --> 00:22:04,320
So what we are saying here that

297
00:22:05,800 --> 00:22:08,880
from this string str,

298
00:22:08,880 --> 00:22:12,120
I want the character act

299
00:22:18,160 --> 00:22:20,040
index zero.

300
00:22:20,760 --> 00:22:22,280
So what this method will do,

301
00:22:22,280 --> 00:22:24,920
the method name is job

302
00:22:25,320 --> 00:22:30,080
and I'm passing a zero in parentheses.

303
00:22:31,080 --> 00:22:33,200
So what this will do,

304
00:22:33,200 --> 00:22:36,360
this will give me back the letter B

305
00:22:36,960 --> 00:22:40,960
because this is the letter
that is present at index number zero.

306
00:22:41,720 --> 00:22:50,160
If I execute this,
I will see in the letter B

307
00:22:52,080 --> 00:22:54,360
and index zero.

308
00:22:54,360 --> 00:22:57,600
Then you quickly
execute this on your end as well

309
00:22:57,840 --> 00:23:01,040
and confirm it with your decision

310
00:23:01,080 --> 00:23:03,480
and liquidate my laws.

311
00:23:03,960 --> 00:25:51,000
I will be back in here in just 2 minutes.

312
00:25:51,000 --> 00:25:53,680
So all of you

313
00:25:54,360 --> 00:26:00,280
get the same results.

314
00:26:00,280 --> 00:26:01,240
Okay.

315
00:26:01,720 --> 00:26:04,880
And and and

316
00:26:04,880 --> 00:26:08,440
tell me if I want to get this edge

317
00:26:10,240 --> 00:26:13,520
or hedge.

318
00:26:13,520 --> 00:26:17,280
What should I ask inside the char method?

319
00:26:18,480 --> 00:26:22,960
So this is 0612, three

320
00:26:24,480 --> 00:26:32,360
nation is at index four.

321
00:26:32,360 --> 00:26:33,080
Okay.

322
00:26:33,560 --> 00:26:39,480
And if I want to get this last dot,

323
00:26:39,480 --> 00:26:41,720
do you think it's a good idea to count

324
00:26:43,200 --> 00:26:45,560
all of the characters default or

325
00:26:47,440 --> 00:26:49,720
there is a better way

326
00:26:59,400 --> 00:27:02,160
those who are saying ends with

327
00:27:02,160 --> 00:27:08,280
what does this what does this matter do?

328
00:27:08,280 --> 00:27:11,760
And does it return the index of something?

329
00:27:12,600 --> 00:27:26,760
Does it return a number?

330
00:27:26,760 --> 00:27:28,360
For example, let's say in

331
00:27:29,720 --> 00:27:32,480
last index I declare a variable

332
00:27:34,040 --> 00:27:38,280
and then so those who are saying and will

333
00:27:40,120 --> 00:27:42,240
follow, what should I do and with

334
00:27:42,240 --> 00:27:45,560
and I should pass the dot here

335
00:27:47,160 --> 00:27:50,840
and we will return a boolean.

336
00:27:50,840 --> 00:27:56,560
So how a boolean value
will help me get the character block

337
00:27:56,560 --> 00:27:58,080
last index

338
00:28:01,400 --> 00:28:04,640
ends with simply returns a boolean.

339
00:28:05,760 --> 00:28:07,880
True or false?

340
00:28:07,880 --> 00:28:12,280
If something is ending
with a specific word or a character,

341
00:28:12,840 --> 00:28:15,040
it will return a true.

342
00:28:15,040 --> 00:28:17,040
Otherwise it will return that false.

343
00:28:17,520 --> 00:28:20,040
So we are only left with this choice.

344
00:28:20,040 --> 00:28:24,840
Either.

345
00:28:24,840 --> 00:28:28,600
Either we manually count

346
00:28:28,680 --> 00:28:31,800
the characters like this

347
00:28:32,400 --> 00:28:33,640
and it will come on down.

348
00:28:33,640 --> 00:28:34,800
This one is

349
00:28:41,080 --> 00:28:45,840
what if the characters will grow?

350
00:28:45,840 --> 00:28:48,400
Let's say a screen contains
1000 characters.

351
00:28:48,440 --> 00:28:53,400
Will you count it manually? No.

352
00:28:54,560 --> 00:28:55,720
So what we can do

353
00:28:57,520 --> 00:28:59,840
instead of counting them manually

354
00:29:03,200 --> 00:29:05,960
a week and

355
00:29:10,520 --> 00:29:11,960
use the length

356
00:29:11,960 --> 00:29:15,720
method, this length method

357
00:29:17,160 --> 00:29:19,560
will it return the last index

358
00:29:20,800 --> 00:29:23,480
or the total number of characters

359
00:29:23,480 --> 00:29:28,440
in the screen?

360
00:29:28,440 --> 00:29:32,520
For example, What do you expect if, let's
say, for example, if I print last index,

361
00:29:33,200 --> 00:29:34,560
what do they expect?

362
00:29:34,560 --> 00:29:37,320
What output I will see

363
00:29:42,320 --> 00:29:44,960
this last index

364
00:29:51,600 --> 00:29:54,800
I want all of you to answer.

365
00:29:54,800 --> 00:29:56,600
If I say

366
00:29:56,600 --> 00:30:00,960
SDR, dot land
and whatever value is being returned

367
00:30:00,960 --> 00:30:04,160
from this land time
storing it inside the last index

368
00:30:05,160 --> 00:30:07,320
and then I'm printing it.

369
00:30:07,320 --> 00:30:10,120
So what output I will see

370
00:30:11,520 --> 00:30:13,640
exactly.

371
00:30:13,640 --> 00:30:17,400
Most of you are wrong, which means either

372
00:30:17,400 --> 00:30:21,600
you guys don't revise things
before coming to the next class

373
00:30:22,400 --> 00:30:27,080
or you don't even open your computers
or not even going through the slides

374
00:30:28,280 --> 00:30:28,840
so it

375
00:30:28,840 --> 00:30:31,840
will not
return and that will not return the 17.

376
00:30:32,760 --> 00:30:37,840
It will return the total count,
which is 18,

377
00:30:37,840 --> 00:30:41,160
just like the land
to matter from the add a

378
00:30:42,280 --> 00:30:44,400
length methods, the return total

379
00:30:44,400 --> 00:30:49,600
number of elements not in the last index,
and because the index is the start

380
00:30:49,600 --> 00:30:53,800
from zero, last index is always

381
00:30:54,120 --> 00:30:57,400
one less than the length.

382
00:30:57,400 --> 00:31:01,680
Let me repeat because index is the start

383
00:31:01,680 --> 00:31:04,160
from zero time in place,
post and disappear channel

384
00:31:05,240 --> 00:31:09,360
because the index is the start from zero.

385
00:31:10,560 --> 00:31:14,400
They are always one less than

386
00:31:15,480 --> 00:31:18,520
the total length or total size

387
00:31:18,520 --> 00:31:21,120
or total number of elements

388
00:31:21,600 --> 00:31:24,520
in that area or string or whatever
you are dealing with.

389
00:31:24,840 --> 00:31:28,160
So it will always be one last time.

390
00:31:28,160 --> 00:31:31,680
So if we are interested
at the last element,

391
00:31:32,680 --> 00:31:35,720
what we have to do, we have to

392
00:31:36,840 --> 00:31:39,440
subtract one

393
00:31:40,680 --> 00:31:42,040
from this.

394
00:31:42,960 --> 00:31:45,600
Let me let me change it

395
00:31:46,920 --> 00:31:49,000
to length instead of last index.

396
00:31:49,720 --> 00:31:50,800
Let me

397
00:31:58,200 --> 00:31:59,080
notice.

398
00:32:00,040 --> 00:32:03,000
SDR not land

399
00:32:04,080 --> 00:32:13,240
and then minus one.

400
00:32:13,240 --> 00:32:17,760
And now I will be getting the start.

401
00:32:17,760 --> 00:32:20,840
I have done something different here.

402
00:32:20,840 --> 00:32:22,960
Everyone look at this.

403
00:32:22,960 --> 00:32:26,800
I have done something different here.

404
00:32:26,800 --> 00:32:28,560
What I am doing.

405
00:32:28,560 --> 00:32:31,840
I have this println method
starting brackets.

406
00:32:32,760 --> 00:32:34,800
Then I have got shot at method.

407
00:32:35,640 --> 00:32:38,160
Then again in brackets
and then the length matter.

408
00:32:38,880 --> 00:32:40,280
Do you see this?

409
00:32:40,480 --> 00:32:44,280
I am calling one method inside
another method

410
00:32:44,280 --> 00:32:47,080
and inside that method
I'm calling another method.

411
00:32:48,320 --> 00:32:51,200
I am nesting

412
00:32:51,560 --> 00:32:53,640
your favorite topic.

413
00:32:54,120 --> 00:32:56,160
I am nesting multiple methods.

414
00:32:57,120 --> 00:33:02,280
I am calling these matters
one inside, another one.

415
00:33:02,280 --> 00:33:03,000
Do you see this?

416
00:33:04,800 --> 00:33:06,240
This print println.

417
00:33:06,240 --> 00:33:08,440
It is a method

418
00:33:08,800 --> 00:33:11,320
and then inside that

419
00:33:11,320 --> 00:33:13,400
I am calling another maturity

420
00:33:13,440 --> 00:33:17,160
which is charged with an entire charter
method.

421
00:33:17,760 --> 00:33:20,720
I am calling another method
which is length

422
00:33:20,720 --> 00:33:28,160
method.

423
00:33:28,160 --> 00:33:30,200
So what would what is happening here?

424
00:33:31,880 --> 00:33:34,800
Plus to Java

425
00:33:36,680 --> 00:33:41,760
we will solve this part.

426
00:33:41,760 --> 00:33:45,400
It is called calling the method

427
00:33:47,240 --> 00:33:48,240
nesting.

428
00:33:48,240 --> 00:33:51,120
The cause of the methods inside
one another.

429
00:33:51,720 --> 00:33:52,720
So not waves.

430
00:33:52,720 --> 00:33:54,960
It's not that hard to understand.

431
00:33:54,960 --> 00:33:57,760
This SDR client or this method will return

432
00:33:58,080 --> 00:34:02,280
the most last start from the most in a

433
00:34:03,600 --> 00:34:07,680
method.

434
00:34:07,680 --> 00:34:10,240
This SDR total and what this will return

435
00:34:12,120 --> 00:34:15,040
the total number of characters,

436
00:34:15,040 --> 00:34:21,480
and that is 80.

437
00:34:21,480 --> 00:34:23,680
And then we are subtracting one

438
00:34:24,800 --> 00:34:28,440
from that 18 -70

439
00:34:29,680 --> 00:34:31,640
will be equal to 18 months.

440
00:34:31,640 --> 00:34:33,960
One will be equal to 17.

441
00:34:33,960 --> 00:34:36,240
Right?

442
00:34:36,240 --> 00:34:39,160
This is 17
that we will be getting from here.

443
00:34:40,600 --> 00:34:43,440
It will be passed

444
00:34:43,440 --> 00:34:47,480
to this SDR DOT charter method.

445
00:34:48,280 --> 00:34:53,800
If we pass 17 to charter method,

446
00:34:54,560 --> 00:34:57,080
it will return us to start

447
00:34:58,080 --> 00:35:00,880
the last character

448
00:35:01,320 --> 00:35:02,320
inside our string.

449
00:35:02,320 --> 00:35:03,120
Right.

450
00:35:04,320 --> 00:35:07,520
So the result of this will be a dock

451
00:35:09,360 --> 00:35:11,760
and then DART

452
00:35:12,280 --> 00:35:14,760
will be passed

453
00:35:14,880 --> 00:35:17,440
to the print and then method

454
00:35:18,760 --> 00:35:21,160
and this println method will print it.

455
00:35:21,680 --> 00:35:26,000
So basically what, what you can do,

456
00:35:26,000 --> 00:35:32,880
print it like this.

457
00:35:32,880 --> 00:35:35,240
For example, in KFC or drive thrus,

458
00:35:36,200 --> 00:35:38,840
you stop at one place right?

459
00:35:38,840 --> 00:35:41,960
You will give them your order.

460
00:35:42,760 --> 00:35:46,320
Then you take your food maybe, let's say,
then you pay, right?

461
00:35:47,800 --> 00:35:49,720
These are all connected, right?

462
00:35:49,720 --> 00:35:52,440
First you have to place the order,
then maybe pay

463
00:35:52,440 --> 00:35:55,040
and pick the ordered end and then leave.

464
00:35:55,560 --> 00:36:00,760
So this thing here,
it is like placing your order first.

465
00:36:01,000 --> 00:36:02,280
And our client will call

466
00:36:03,200 --> 00:36:04,440
this lantern method, which

467
00:36:04,440 --> 00:36:07,560
will give 18 different window functions

468
00:36:08,160 --> 00:36:10,640
all together, happening all together.

469
00:36:10,640 --> 00:36:13,080
So this will calculate the last index.

470
00:36:13,520 --> 00:36:17,960
Then that last index
will be fed to the chart or method.

471
00:36:18,480 --> 00:36:22,320
That method will go
and pick the last character,

472
00:36:22,800 --> 00:36:26,600
and then that last character
will be given to put into the method

473
00:36:26,960 --> 00:36:30,960
which will print it.

474
00:36:30,960 --> 00:36:35,280
So here multiple methods are being called
one inside another one

475
00:36:36,160 --> 00:36:37,920
that it makes sense.

476
00:36:38,640 --> 00:36:41,840
We can break it down, separate
to a separately as well.

477
00:36:41,840 --> 00:36:45,040
For example, this.

478
00:36:45,040 --> 00:36:49,040
So now I will unfold this,
I will unfold this

479
00:36:49,040 --> 00:36:50,840
and we will go step by step.

480
00:36:50,840 --> 00:36:58,080
And this is how it will look like.

481
00:36:58,080 --> 00:37:01,520
So first of all, I will do this

482
00:37:01,520 --> 00:37:10,560
part.

483
00:37:10,560 --> 00:37:13,800
Oh, by the way,
those who are following me, I am changing

484
00:37:13,800 --> 00:37:16,800
this last index to

485
00:37:18,320 --> 00:37:20,440
length that it does not confusing.

486
00:37:21,600 --> 00:37:23,240
So end

487
00:37:24,200 --> 00:37:26,520
last index is equal to

488
00:37:29,040 --> 00:37:32,520
SDR dart

489
00:37:32,520 --> 00:37:33,680
length

490
00:37:34,440 --> 00:37:35,960
minus one

491
00:37:37,280 --> 00:37:44,040
and print it.

492
00:37:44,040 --> 00:37:48,400
Let me also put in some stars
so that you can see the difference.

493
00:37:49,800 --> 00:37:52,320
It's shift six

494
00:37:52,600 --> 00:37:56,560
refactoring.

495
00:37:56,560 --> 00:37:58,600
Okay, so

496
00:37:59,400 --> 00:38:02,840
welcome to last index and then

497
00:38:06,600 --> 00:38:11,560
once we have the last index,

498
00:38:11,560 --> 00:38:16,720
we can get the character and that index

499
00:38:16,720 --> 00:38:21,160
by pulling the charter method.

500
00:38:22,240 --> 00:38:27,040
And charter
tomato requires us to pass a number.

501
00:38:27,720 --> 00:38:30,960
And that number
we already have works disaster index

502
00:38:32,880 --> 00:38:36,840
and then we have the print method
which is printing it.

503
00:38:37,920 --> 00:38:41,040
So this code, this line

504
00:38:41,040 --> 00:38:46,400
here, it is

505
00:38:46,480 --> 00:38:49,560
same as

506
00:38:52,000 --> 00:38:53,080
this one.

507
00:38:53,400 --> 00:38:56,400
And you see the benefit of this approach.

508
00:38:56,400 --> 00:39:00,360
Now, something
that can be done in one line.

509
00:39:00,360 --> 00:39:03,240
If you do it one by one like this,

510
00:39:03,840 --> 00:39:07,440
it will take three or four lines
and the result will be same.

511
00:39:08,640 --> 00:39:09,600
So here for us,

512
00:39:09,600 --> 00:39:13,080
the last index will be calculated and then

513
00:39:14,280 --> 00:39:16,480
the character, that index will be first

514
00:39:16,960 --> 00:39:20,040
and then it will be printed here.

515
00:39:20,040 --> 00:39:21,480
The exact same result.

516
00:39:21,480 --> 00:39:25,120
Part one is doing all of that on this.

517
00:39:25,120 --> 00:39:29,280
The line, look,

518
00:39:30,000 --> 00:39:37,560
this is giving us.

519
00:39:37,560 --> 00:39:43,400
So this line here
it is returning us to start here.

520
00:39:43,400 --> 00:39:51,160
And then we are we're ending
the last index and then our daughter game.

521
00:39:51,160 --> 00:39:53,880
So it all to the same output.

522
00:39:53,880 --> 00:39:57,160
This is our
and then we can go dog for one second

523
00:39:57,160 --> 00:40:00,040
so that you can see two different

524
00:40:00,600 --> 00:40:04,200
and same output dot, dot.

525
00:40:04,200 --> 00:40:06,560
But in one case
we have to write three lines

526
00:40:08,080 --> 00:40:11,320
in another case
we are writing this only one.

527
00:40:11,320 --> 00:40:12,800
So this is possible.

528
00:40:12,800 --> 00:40:16,080
You can call multiple methods

529
00:40:16,920 --> 00:41:31,800
one inside, another one.

530
00:41:31,800 --> 00:41:34,800
Oh, sorry.
Yes. And the only other. Correct.

531
00:41:36,360 --> 00:41:39,480
And that's why we are subtracting minus
one value.

532
00:41:39,520 --> 00:41:43,320
Would you prefer variable strategy
or sticking with our client?

533
00:41:44,640 --> 00:41:46,640
Darling, this is this is.

534
00:41:46,640 --> 00:41:48,120
This is what I will do.

535
00:41:48,600 --> 00:41:50,160
This one here.

536
00:41:51,960 --> 00:41:53,880
This is nothing more.

537
00:41:53,880 --> 00:42:03,120
More lines of code.

538
00:42:03,120 --> 00:42:06,480
And that's going to wait

539
00:42:06,480 --> 00:42:22,120
here.

540
00:42:22,120 --> 00:42:25,360
Is there a method of string
showing index number, for example?

541
00:42:25,360 --> 00:42:28,080
I right,
it will give me index number esthetics.

542
00:42:28,080 --> 00:42:31,000
This is what we will learn next.

543
00:42:31,000 --> 00:42:32,640
This is what we will learn next.

544
00:42:32,640 --> 00:43:00,640
After this method at

545
00:43:06,840 --> 00:43:08,480
I do not understand

546
00:43:08,480 --> 00:43:10,920
the minus one since we have learned method

547
00:43:13,000 --> 00:43:15,400
and you re-explain

548
00:43:22,880 --> 00:43:26,400
of minus x.

549
00:43:26,400 --> 00:43:38,600
What?

550
00:43:38,600 --> 00:43:40,120
Okay, so

551
00:43:41,880 --> 00:43:43,920
dark matter the

552
00:44:27,960 --> 00:44:28,840
satellite

553
00:44:29,520 --> 00:44:30,400
internet. I don't know.

554
00:44:30,400 --> 00:44:33,080
Something is wrong with it.

555
00:44:33,160 --> 00:44:35,160
I have changed the connection. Hopefully

556
00:44:36,200 --> 00:44:38,280
we will be good now

557
00:44:50,040 --> 00:44:52,360
in your connection box.

558
00:44:52,360 --> 00:44:54,040
Okay. The

559
00:44:55,520 --> 00:44:58,680
everyone can hear me now right

560
00:45:00,440 --> 00:45:01,520
now Department.

561
00:45:01,520 --> 00:45:02,360
Sorry

562
00:45:03,720 --> 00:45:08,760
so dark matter can give us
and the character

563
00:45:10,080 --> 00:45:11,840
and the index

564
00:45:11,840 --> 00:45:14,800
that we specify inside the parent
teacher is

565
00:45:15,840 --> 00:45:24,720
everyone understands this.

566
00:45:24,720 --> 00:45:25,400
Okay.

567
00:45:25,560 --> 00:45:27,920
Do you think we can also write a loop

568
00:45:29,160 --> 00:45:32,400
to get all the characters one by one

569
00:45:32,400 --> 00:45:38,680
from this string?

570
00:45:38,680 --> 00:45:39,360
Yeah.

571
00:45:39,360 --> 00:45:41,600
So let's do that.

572
00:45:42,760 --> 00:45:45,840
Which type offer loop

573
00:45:45,840 --> 00:45:48,240
normal one enhance one.

574
00:45:48,600 --> 00:45:50,720
Why loop do y loop

575
00:45:52,680 --> 00:45:54,840
and likes why loop

576
00:45:56,200 --> 00:46:00,400
the Let's use the normal loop for now

577
00:46:00,400 --> 00:46:04,880
because at this point you don't understand
how to use the enhanced one.

578
00:46:05,840 --> 00:46:07,760
Was there any event or something?

579
00:46:07,760 --> 00:46:14,040
Why everyone most of
you have new pictures.

580
00:46:14,040 --> 00:46:17,720
Am I the only one who is using the same
picture for last three years?

581
00:46:18,880 --> 00:46:21,880
Party?

582
00:46:21,880 --> 00:46:22,480
Okay.

583
00:46:23,400 --> 00:46:24,360
Okay.

584
00:46:24,360 --> 00:46:28,000
So this loop, should I start it from zero

585
00:46:28,960 --> 00:46:32,600
or something else? Yes.

586
00:46:33,160 --> 00:46:34,680
And what should be this?

587
00:46:34,680 --> 00:46:36,720
I less than

588
00:46:41,400 --> 00:46:43,960
SDR No Land.

589
00:46:44,840 --> 00:46:47,040
Why? I'm not subtracting here.

590
00:46:47,120 --> 00:47:00,480
Why Am not subtracting minus one here.

591
00:47:00,480 --> 00:47:01,440
Exactly.

592
00:47:01,440 --> 00:47:05,400
Because here we are using
the less than sign.

593
00:47:05,880 --> 00:47:10,320
We are not using
the less than equal to sign.

594
00:47:10,320 --> 00:47:15,240
So let me see parental two point statement
and then

595
00:47:16,240 --> 00:47:20,760
SDR got to fact I

596
00:47:22,920 --> 00:47:31,560
and this on it.

597
00:47:31,560 --> 00:47:32,280
Okay.

598
00:47:32,280 --> 00:47:35,800
So everyone,
can you confirm if you get the same result

599
00:47:36,120 --> 00:47:38,240
each and every character

600
00:47:39,000 --> 00:47:41,240
being printed on a separate line

601
00:47:46,920 --> 00:47:48,320
and what is this?

602
00:47:48,320 --> 00:47:51,200
But why? There is this empty after edge?

603
00:47:51,200 --> 00:47:51,960
There is nothing.

604
00:47:51,960 --> 00:48:00,320
And then, yes,
it is because of this space.

605
00:48:00,320 --> 00:48:01,040
Okay.

606
00:48:01,040 --> 00:48:04,440
Is there anyone who do not understand
this score that I have written here

607
00:48:16,120 --> 00:48:22,440
on good.

608
00:48:22,440 --> 00:48:26,240
Okay, let me give you a challenge.

609
00:48:26,400 --> 00:48:29,520
Let's see how many of you can solve it.

610
00:48:29,520 --> 00:48:31,960
You have to write a piece of score

611
00:48:32,520 --> 00:48:35,400
which will count how times

612
00:48:35,400 --> 00:48:38,000
the number e has appeared

613
00:48:38,640 --> 00:48:43,360
in this screen.

614
00:48:43,360 --> 00:48:47,200
You have to write a piece of board
that will count

615
00:48:47,640 --> 00:48:51,560
how many times
the letter E has appeared in this string.

616
00:48:52,800 --> 00:49:29,600
Let me write it down.

617
00:49:29,600 --> 00:49:33,680
Do you think it's possible
or It's very hard to figure out

618
00:49:33,680 --> 00:49:39,480
the logic for this.

619
00:49:39,480 --> 00:49:49,560
Do you want me to give a hint?

620
00:49:49,560 --> 00:49:52,920
You can use a false conditions

621
00:49:54,240 --> 00:49:57,480
and you might need to declare

622
00:49:58,080 --> 00:50:00,920
a variable to hold the count.

623
00:50:02,520 --> 00:50:05,560
You have to use the false conditions

624
00:50:05,560 --> 00:50:08,120
and you might need a variable

625
00:50:08,600 --> 00:50:36,640
to hold the count.

626
00:50:36,640 --> 00:51:04,440
Do you think it's possible now
or are you still hard to figure out?

627
00:51:04,440 --> 00:51:08,440
And I think you have done very similar,

628
00:51:08,840 --> 00:51:12,280
very similar thing in your adage as well.

629
00:51:13,000 --> 00:51:13,920
Very, very similar.

630
00:51:15,360 --> 00:51:17,400
So I don't know if you maybe you want to

631
00:51:18,760 --> 00:51:20,880
look back at your knowledge of how to

632
00:51:59,160 --> 00:51:59,640
let me know

633
00:51:59,640 --> 00:52:27,160
once you are done.

634
00:52:27,160 --> 00:52:30,320
There you go.

635
00:52:30,320 --> 00:52:54,520
We have a new picture from C as well.

636
00:52:54,520 --> 00:52:57,720
Yes. Alex,
please don't share the code and also

637
00:52:57,720 --> 00:53:01,040
use some proper good names
for your classes.

638
00:53:01,440 --> 00:53:18,880
We are calling your class and dee
dee dee dee dee dee dee dee dee dee.

639
00:53:18,880 --> 00:53:21,920
How many of you are stuck?

640
00:53:21,920 --> 00:53:42,600
Not know how to do this.

641
00:53:42,600 --> 00:53:43,920
By the way, the answer is two.

642
00:53:43,920 --> 00:53:45,640
You should be getting

643
00:53:45,960 --> 00:53:48,200
two as down to

644
00:54:44,400 --> 00:54:45,360
30 more seconds.

645
00:54:45,360 --> 00:54:50,280
And then I, I

646
00:54:50,480 --> 00:54:53,680
and I want all of you to try

647
00:55:45,240 --> 00:55:46,320
now. That's correct.

648
00:55:46,320 --> 00:55:46,920
Okay.

649
00:55:47,160 --> 00:55:51,960
So I hope it was easy for all of you.

650
00:55:51,960 --> 00:55:55,560
So we need one variable
to hold the count and

651
00:55:56,720 --> 00:55:57,840
count

652
00:55:58,560 --> 00:55:59,120
it initially.

653
00:55:59,120 --> 00:56:02,480
You can initialize it with zero

654
00:56:02,560 --> 00:56:05,160
and then instead of printing it,

655
00:56:06,480 --> 00:56:09,400
you can see if

656
00:56:11,640 --> 00:56:15,360
asked to start cha add.

657
00:56:16,480 --> 00:56:19,880
I is equal

658
00:56:19,880 --> 00:56:22,520
to equal to the letter E

659
00:56:25,400 --> 00:56:29,240
and then increase the count

660
00:56:29,240 --> 00:56:30,560
plus plus

661
00:56:33,440 --> 00:56:37,000
and once you are done

662
00:56:37,480 --> 00:56:40,680
then you can put into account deficit.

663
00:56:40,760 --> 00:56:43,040
This was the solution

664
00:56:46,240 --> 00:56:52,520
to it.

665
00:56:53,160 --> 00:56:59,120
Is there anyone who has any questions?

666
00:56:59,120 --> 00:57:05,360
Is it okay to use the political tool
string?

667
00:57:05,360 --> 00:57:07,920
Ehab Is it a string or character?

668
00:57:09,360 --> 00:57:12,360
It's not a string.

669
00:57:12,360 --> 00:57:13,120
With strings.

670
00:57:13,120 --> 00:57:16,120
We use double codes

671
00:57:16,120 --> 00:57:18,360
and lookup the name of the method as well.

672
00:57:18,920 --> 00:57:20,040
It's a character.

673
00:57:20,040 --> 00:57:26,000
It is returning you a character.

674
00:57:26,000 --> 00:57:28,600
Very. You are using double codes
instead of the same.

675
00:57:28,920 --> 00:57:42,600
I kept using double code
and wondering why I was getting better.

676
00:57:42,600 --> 00:57:45,800
Then we changed method to check for case
sensitivity.

677
00:57:45,840 --> 00:57:49,280
Yes. Okay.

678
00:57:49,600 --> 00:58:07,800
Do you have any questions from here?

679
00:58:07,800 --> 00:58:10,600
This is running through each index

680
00:58:11,400 --> 00:58:15,960
and or child
which gives indexes, not indexes.

681
00:58:15,960 --> 00:58:22,080
It is going through each element, not
index each element with the help of index,

682
00:58:23,080 --> 00:58:24,000
with the help of

683
00:58:24,000 --> 00:58:27,920
index, it is going through
all of the characters

684
00:58:27,920 --> 00:58:31,840
one by one,
and then we are checking those characters.

685
00:58:31,840 --> 00:58:36,720
If any of those character
is the character,

686
00:58:37,400 --> 00:58:42,200
if it is, we increase the count.

687
00:58:42,200 --> 00:58:44,040
Yeah, let's debug it.

688
00:58:44,400 --> 00:58:49,920
Let the label point here.

689
00:58:49,920 --> 00:58:52,680
Yes, that's correct.

690
00:58:52,760 --> 00:58:53,960
We don't go

691
00:58:54,360 --> 00:58:56,480
look, we need to

692
00:58:58,360 --> 00:59:02,440
so initially counted zero.

693
00:59:02,440 --> 00:59:04,560
Then we start at look from zero

694
00:59:06,480 --> 00:59:08,880
and this charted method

695
00:59:09,960 --> 00:59:12,920
will give us the character

696
00:59:12,920 --> 00:59:15,960
which is present at index zero.

697
00:59:15,960 --> 00:59:18,040
Which character is present

698
00:59:18,040 --> 00:59:22,320
at index number zero.

699
00:59:22,320 --> 00:59:23,800
It's B

700
00:59:24,480 --> 00:59:28,080
is B is B equal to eight?

701
00:59:28,800 --> 00:59:31,920
Is this condition true or false?

702
00:59:31,920 --> 00:59:33,080
False.

703
00:59:33,560 --> 00:59:36,280
The condition is false.

704
00:59:36,280 --> 00:59:39,880
We will not enter the if condition

705
00:59:39,880 --> 00:59:41,200
other than the if condition.

706
00:59:41,200 --> 00:59:48,120
Is there anything else
prevalent inside this loop? No.

707
00:59:49,120 --> 00:59:52,080
So we go back

708
00:59:52,080 --> 00:59:54,960
and fetch the next character.

709
00:59:54,960 --> 00:59:55,800
So here.

710
00:59:55,800 --> 01:00:00,680
So I, I will be increased from 0 to 1

711
01:00:01,800 --> 01:00:04,240
and then we will fetch the character

712
01:00:05,400 --> 01:00:07,920
at index one.

713
01:00:07,920 --> 01:00:10,440
Which character is present
at index number one

714
01:00:14,320 --> 01:00:22,200
mean is a equal to the Yes.

715
01:00:23,320 --> 01:00:26,520
If condition will become true

716
01:00:26,720 --> 01:00:28,720
and if the condition is true,

717
01:00:28,720 --> 01:00:31,720
we increase the count

718
01:00:31,720 --> 01:00:34,920
so the count will be increased by one.

719
01:00:35,760 --> 01:00:38,600
Initially the count was zero,

720
01:00:38,600 --> 01:00:41,800
now we've increased to one.

721
01:00:41,800 --> 01:00:45,080
So look, count right now is one.

722
01:00:46,960 --> 01:00:50,200
Then we fetch the next character

723
01:00:50,200 --> 01:00:53,520
present at index number two,

724
01:00:53,520 --> 01:00:56,040
which is the character T

725
01:00:57,240 --> 01:00:59,760
again, B is not required where.

726
01:00:59,760 --> 01:01:02,000
So condition will fail

727
01:01:03,320 --> 01:01:05,640
then refer to the next, next, next, next.

728
01:01:05,640 --> 01:01:08,800
It keeps on doing
this for all the characters

729
01:01:09,840 --> 01:01:11,080
and when it sees the letter

730
01:01:11,080 --> 01:01:16,040
E, it includes the value of count,
otherwise empty

731
01:01:16,040 --> 01:01:18,480
and looking to enter to the end.

732
01:01:18,720 --> 01:01:22,640
We will get the count,
which will tell us how many times

733
01:01:22,640 --> 01:01:30,120
we encountered dilatory.

734
01:01:30,120 --> 01:01:31,880
Oh yeah.

735
01:01:32,480 --> 01:01:35,040
What if there was an uppercase here
somewhere?

736
01:01:35,680 --> 01:01:37,840
It will not count it.

737
01:01:38,280 --> 01:01:41,600
It will not count it.

738
01:01:41,600 --> 01:01:44,400
If you want to.

739
01:01:44,400 --> 01:01:47,400
Actually 17 is

740
01:01:47,400 --> 01:02:09,240
incorrect.

741
01:02:09,240 --> 01:02:11,280
Okay, so let's say we have a

742
01:02:12,600 --> 01:02:14,280
90 string, right?

743
01:02:14,280 --> 01:02:18,720
And somewhere
we have the uppercase as one.

744
01:02:18,720 --> 01:02:21,960
So now if we run this again,

745
01:02:23,040 --> 01:02:25,800
it will still only count to be

746
01:02:27,080 --> 01:02:28,560
a lowercase means.

747
01:02:28,560 --> 01:02:32,920
If we want to check the applications,
we can use the R,

748
01:02:34,680 --> 01:02:38,560
and then we can say SDR, Dart,

749
01:02:38,600 --> 01:02:40,640
Char and

750
01:02:43,240 --> 01:02:45,840
I is equal to equal to.

751
01:02:47,560 --> 01:02:48,240
But see,

752
01:02:49,440 --> 01:02:52,440
so now

753
01:02:52,440 --> 01:02:55,320
that it sees the location

754
01:02:55,320 --> 01:02:59,520
or whether it sees the uppercase
in any of these cases,

755
01:03:00,360 --> 01:03:06,200
it will increase the count.

756
01:03:06,200 --> 01:03:08,640
So now we see six

757
01:03:12,920 --> 01:03:15,000
yes, we can use the times we had

758
01:03:16,560 --> 01:03:18,200
to use the ignore case.

759
01:03:18,200 --> 01:03:20,400
We have to convert all of the

760
01:03:22,440 --> 01:03:25,200
string to lowercase.

761
01:03:25,560 --> 01:03:28,560
And if we do that,

762
01:03:28,560 --> 01:03:33,440
it will be a lot of unnecessary
processing.

763
01:03:34,280 --> 01:03:39,120
Imagine there are 1 million elements
just the Java code

764
01:03:39,120 --> 01:03:42,960
will convert all of those 1
million elements to lowercase.

765
01:03:43,720 --> 01:03:47,040
Then you will again
go through all of those 1

766
01:03:47,040 --> 01:03:51,240
million elements to check
whether it contains the letter E or not.

767
01:03:51,680 --> 01:03:54,920
So it's actually double
the processing here.

768
01:03:54,920 --> 01:03:57,200
Computer has to do at least double

769
01:03:57,920 --> 01:04:00,920
the amount of work will get doubled
for your computer.

770
01:04:01,720 --> 01:04:05,160
So whenever you are trying to think
about the logic, also think

771
01:04:06,160 --> 01:04:07,840
about how much work your

772
01:04:07,840 --> 01:04:11,200
has to do in that case

773
01:04:22,240 --> 01:04:24,920
out of that word within a string,
not characters,

774
01:04:25,080 --> 01:04:29,280
I will show you that I would.

775
01:04:29,280 --> 01:04:30,720
I will show you how to replace.

776
01:04:30,720 --> 01:04:33,240
As with today,
we will learn all of these today.

777
01:04:33,960 --> 01:04:46,760
So are there any questions from here?

778
01:04:46,760 --> 01:04:48,440
Okay, perfect

779
01:04:49,800 --> 01:04:59,840
to with

780
01:05:27,400 --> 01:05:29,760
that we actually imagine we have

781
01:05:31,440 --> 01:05:32,760
this screen

782
01:05:33,560 --> 01:05:35,800
and from this the screen

783
01:05:38,040 --> 01:05:40,080
we want to see

784
01:05:43,520 --> 01:05:46,240
and the index of

785
01:05:46,240 --> 01:05:51,120
the index of this letter, five.

786
01:05:51,120 --> 01:05:53,120
So counting manually,

787
01:05:55,040 --> 01:05:57,200
all of the characters

788
01:05:58,400 --> 01:06:00,800
never, ever recommended.

789
01:06:01,320 --> 01:06:03,120
And we don't actually have to do this.

790
01:06:03,120 --> 01:06:05,160
But there is there is a method

791
01:06:06,280 --> 01:06:09,360
and whatever you everyone let's do this
exercise

792
01:06:10,560 --> 01:06:14,200
type the name of the variable SDR
and then press a dot

793
01:06:15,200 --> 01:06:17,480
and then you will see the list of all

794
01:06:17,480 --> 01:06:20,760
the available methods in the spring class.

795
01:06:21,760 --> 01:06:22,360
Go through

796
01:06:22,360 --> 01:06:24,360
all of those methods and tell me the name.

797
01:06:25,520 --> 01:06:27,440
Try to guess the name of the matter,

798
01:06:27,440 --> 01:06:29,560
which will tell me the index

799
01:06:30,480 --> 01:06:33,120
of a specific character from a string

800
01:06:35,680 --> 01:06:38,080
and go through and

801
01:06:39,640 --> 01:06:41,520
and then try to.

802
01:06:41,520 --> 01:06:45,240
You can also use Google.

803
01:06:45,240 --> 01:06:49,400
You can also use Google Drive
to go on Google and search for a method

804
01:06:49,680 --> 01:06:53,200
which in which can tell you
the index of a character

805
01:06:53,720 --> 01:07:09,120
from a string.

806
01:07:09,120 --> 01:07:10,080
Yeah.

807
01:07:10,080 --> 01:07:13,160
The name of the method

808
01:07:13,160 --> 01:07:16,080
is index of

809
01:07:16,280 --> 01:07:16,680
election.

810
01:07:16,680 --> 01:07:19,720
For example, for some reason
you don't have

811
01:07:19,720 --> 01:07:22,800
the access to the internet.

812
01:07:22,800 --> 01:07:25,640
What you can do, you can put your cursor

813
01:07:26,880 --> 01:07:31,400
on the method name anywhere here
and then you can press control.

814
01:07:31,440 --> 01:07:40,800
Q Control

815
01:07:42,600 --> 01:07:44,240
and then. Q

816
01:07:44,800 --> 01:07:56,440
Yes, and then then this

817
01:07:58,480 --> 01:07:59,680
window should pop up.

818
01:07:59,680 --> 01:08:00,520
You see this window?

819
01:08:00,520 --> 01:08:01,480
Let me do it again.

820
01:08:01,480 --> 01:08:04,000
So put your cursor anywhere.

821
01:08:05,680 --> 01:08:08,280
And even if you have your mouse,
you see this

822
01:08:09,800 --> 01:08:10,760
a lot of methods.

823
01:08:10,760 --> 01:08:15,040
Just click on any of this, click
any of this.

824
01:08:15,600 --> 01:08:17,240
The same for Mac.

825
01:08:17,240 --> 01:08:25,120
Hover your mouse
and then click on any of the matters.

826
01:08:25,120 --> 01:08:27,320
Do you all see the explanation

827
01:08:28,400 --> 01:08:30,960
about this method

828
01:08:33,720 --> 01:08:35,680
for Mac and seeing How about your mouse?

829
01:08:35,680 --> 01:08:37,240
I need to show you

830
01:08:37,960 --> 01:08:41,360
what all this explanation says.

831
01:08:41,360 --> 01:08:46,720
Read it, Read this explanation and
explain to me what will work this method.

832
01:08:46,720 --> 01:08:47,560
Isabelle

833
01:08:48,520 --> 01:09:16,400
What are they saying in the explanation?

834
01:09:16,400 --> 01:09:20,000
This method returns the index

835
01:09:20,760 --> 01:09:25,200
within this string of the first occurrence

836
01:09:25,200 --> 01:09:28,240
of specified character.

837
01:09:29,120 --> 01:09:37,280
Meaning
if I specify, let's say the number five,

838
01:09:38,320 --> 01:09:41,160
it will return me the index

839
01:09:41,760 --> 01:09:47,240
at which in this letter five present.

840
01:09:47,240 --> 01:09:51,680
So the name of the matter is an index of
If I don't understand

841
01:09:51,680 --> 01:09:54,600
that method I can cover
my mouse would be my third name.

842
01:09:55,360 --> 01:09:58,200
I can read your explanation.

843
01:09:58,200 --> 01:10:00,560
I can also see some examples here

844
01:10:01,760 --> 01:10:03,560
and then I can run it.

845
01:10:03,560 --> 01:10:05,000
And also

846
01:10:07,120 --> 01:10:08,480
go to the answer.

847
01:10:08,480 --> 01:10:11,040
We all get the answer it.

848
01:10:11,040 --> 01:10:13,200
And do you also understand
what this method

849
01:10:13,200 --> 01:10:21,560
is doing?

850
01:10:21,560 --> 01:10:37,840
Perfect.

851
01:10:37,840 --> 01:10:38,840
Okay.

852
01:10:38,840 --> 01:10:42,080
If five is present
two times, let's say everyone,

853
01:10:42,240 --> 01:10:45,360
if five is present two times

854
01:10:45,360 --> 01:10:48,960
three, the explanation again
and tell me for this method is going to do

855
01:10:50,680 --> 01:10:53,040
read the explanation again
and tell me what this method

856
01:10:53,040 --> 01:11:06,000
is going to do.

857
01:11:06,000 --> 01:11:08,400
It is only going to return

858
01:11:09,440 --> 01:11:12,160
the first index.

859
01:11:12,840 --> 01:11:17,680
The index of the first occurrence.

860
01:11:17,680 --> 01:11:18,480
Okay,

861
01:11:19,120 --> 01:11:21,840
so now,
because we are done with the basics

862
01:11:22,560 --> 01:11:28,400
slowly, I will teach you
how to be independent, how to use Google,

863
01:11:28,640 --> 01:11:32,160
how to use charity beauty,
how to use documentation,

864
01:11:32,720 --> 01:11:35,320
how to try to guess things.

865
01:11:35,760 --> 01:11:39,520
So slowly you can be independent
and then start writing things

866
01:11:39,520 --> 01:11:43,680
on your own.

867
01:11:43,680 --> 01:11:47,560
Okay, so this is how this matter works.

868
01:11:48,320 --> 01:11:51,600
It basically gives you the index of

869
01:11:53,160 --> 01:11:55,520
the first occurrence

870
01:11:55,520 --> 01:11:58,080
of the character that you pass here.

871
01:11:58,840 --> 01:12:04,400
For example, if I was asked here,
what do you think?

872
01:12:04,440 --> 01:12:04,880
What are

873
01:12:08,400 --> 01:12:13,240
exactly I will be getting a zero.

874
01:12:13,240 --> 01:12:14,200
I needed this answer.

875
01:12:14,200 --> 01:12:23,040
I've seen it.

876
01:12:23,240 --> 01:12:28,280
If you find index of some characters,

877
01:12:28,280 --> 01:12:31,680
if you find

878
01:12:31,880 --> 01:12:34,760
index of some characters and it's

879
01:12:35,760 --> 01:12:36,720
in one

880
01:12:36,720 --> 01:12:40,600
out, yes, we can find

881
01:12:40,600 --> 01:12:45,040
the index of some characters.

882
01:12:45,040 --> 01:12:49,240
You want to find the index of
multiple characters in one single result.

883
01:12:49,280 --> 01:12:52,480
Maybe it will give me

884
01:12:53,440 --> 01:12:57,360
a small possible.

885
01:12:57,360 --> 01:12:59,240
It's not possible

886
01:13:00,840 --> 01:13:03,760
and not possible
using the building methods,

887
01:13:04,280 --> 01:13:06,840
but you can write your own logic.

888
01:13:07,680 --> 01:13:10,560
So I guess in the class

889
01:13:11,120 --> 01:13:14,080
I will teach you
how to create your own methods.

890
01:13:15,120 --> 01:13:17,520
If let's say something is not present,

891
01:13:17,960 --> 01:13:20,480
something is not done
by a job by developers,

892
01:13:21,240 --> 01:13:25,200
and we have our custom requirements,
our own different requirements

893
01:13:25,200 --> 01:13:27,600
for which there is no method

894
01:13:27,600 --> 01:13:28,560
already present,

895
01:13:28,560 --> 01:13:31,200
you can write your own
starting from tomorrow

896
01:13:31,200 --> 01:13:33,320
and you will be able
to write your own matters. So.

897
01:13:33,320 --> 01:13:35,080
So don't worry about

898
01:13:42,320 --> 01:13:47,320
okay you know
let me cleared and a lot of times

899
01:14:00,600 --> 01:14:02,520
it's the same string

900
01:14:02,600 --> 01:14:04,560
that we used for the previous

901
01:14:04,560 --> 01:14:16,480
of society.

902
01:14:16,480 --> 01:14:20,640
Okay, There is this term
which is called substring.

903
01:14:21,440 --> 01:14:23,400
What do you understand

904
01:14:23,680 --> 01:14:25,280
from this term? Substring?

905
01:14:25,280 --> 01:14:26,160
We're doing all we can.

906
01:14:26,160 --> 01:14:27,600
What it will be

907
01:14:31,320 --> 01:14:32,000
nested.

908
01:14:32,000 --> 01:14:35,680
A string.

909
01:14:35,680 --> 01:14:42,400
String within a string.

910
01:14:42,400 --> 01:14:44,400
A part of this strain.

911
01:14:44,400 --> 01:14:44,720
Can I.

912
01:14:44,720 --> 01:14:48,720
Can I say that a smaller part of,

913
01:14:48,720 --> 01:15:07,400
this bigger string.

914
01:15:07,400 --> 01:15:09,720
Okay, so

915
01:15:10,520 --> 01:15:13,080
let's say, for example,

916
01:15:13,160 --> 01:15:16,880
I am interested in only this part

917
01:15:18,080 --> 01:15:18,800
of the string.

918
01:15:18,800 --> 01:15:20,520
They want to get

919
01:15:21,560 --> 01:15:22,640
this part of the string.

920
01:15:22,640 --> 01:15:26,760
Or let's say
I only want this part or let's say

921
01:15:27,360 --> 01:15:30,160
I only want this part.

922
01:15:30,160 --> 01:15:35,960
So from this bigger string,
I want a small chunk from this string.

923
01:15:36,120 --> 01:15:38,120
So is it possible to do that?

924
01:15:38,120 --> 01:15:43,080
Yes, it is possible.

925
01:15:43,080 --> 01:15:45,040
And the method?

926
01:15:45,040 --> 01:15:48,960
Try to guess the name for the method.

927
01:15:48,960 --> 01:15:53,040
I want to get a substring
from this middle string.

928
01:15:53,400 --> 01:15:54,880
Right. And just the name for doing it

929
01:16:01,080 --> 01:16:03,160
starts with and ends with.

930
01:16:03,160 --> 01:16:07,960
The first thing was that
who whoever is giving you this comes up

931
01:16:08,760 --> 01:16:11,320
he or she is trying to misguide

932
01:16:11,320 --> 01:16:13,680
because these are the wrong methods
to do that

933
01:16:16,240 --> 01:16:18,440
and they return in boolean.

934
01:16:18,440 --> 01:16:23,760
True or false,
they don't give you some strings.

935
01:16:23,760 --> 01:16:26,240
Try to actually Google

936
01:16:26,440 --> 01:16:28,600
or try to see any method is available.

937
01:16:28,720 --> 01:16:31,800
Is there any method present

938
01:16:31,800 --> 01:16:34,680
in the string class
which is called a substring?

939
01:16:35,400 --> 01:16:38,640
Everyone tried to search for this method

940
01:16:38,640 --> 01:16:53,480
of yeah,

941
01:16:54,480 --> 01:16:58,840
the method is called substring. So

942
01:16:59,960 --> 01:17:03,320
and this is how it works.

943
01:17:03,320 --> 01:17:09,880
You'll get back,

944
01:17:09,880 --> 01:17:13,200
you get back a smaller, shorter string

945
01:17:14,600 --> 01:17:16,720
from this bigger string
and how you can use

946
01:17:16,760 --> 01:17:19,800
your SDR dart

947
01:17:19,920 --> 01:17:24,840
substring.

948
01:17:24,840 --> 01:17:31,680
Okay, so let's say for example,

949
01:17:31,680 --> 01:17:33,880
how many characters

950
01:17:34,720 --> 01:17:41,800
are there in this highlighted string?

951
01:17:41,800 --> 01:17:42,960
You don't have to count them.

952
01:17:44,640 --> 01:17:47,040
You don't have to count them.

953
01:17:47,040 --> 01:17:49,520
And it is the wrong

954
01:17:49,520 --> 01:17:53,520
answer.

955
01:17:53,520 --> 01:17:57,040
No, it's correct.

956
01:17:57,040 --> 01:18:08,640
17 around

957
01:18:08,640 --> 01:18:11,840
1819, which is

958
01:18:13,840 --> 01:18:17,280
okay,
you actually don't need to count them

959
01:18:17,280 --> 01:18:19,760
and really
look at the bottom of your intelligent

960
01:18:23,280 --> 01:18:26,560
look at this party.

961
01:18:26,560 --> 01:18:29,160
Everyone look at this part.

962
01:18:29,680 --> 01:18:33,360
If I am highlighting badge,

963
01:18:33,360 --> 01:18:36,200
if I am highlighting badge

964
01:18:36,200 --> 01:18:38,360
by looking at the bottom
of your intelligent

965
01:18:38,400 --> 01:18:41,440
and you tell me how many characters
are present

966
01:18:41,440 --> 01:18:45,040
in the badge word by

967
01:18:46,280 --> 01:18:49,520
if I highlight this part
and you tell me how many characters

968
01:18:49,520 --> 01:18:51,960
without counting

969
01:18:52,560 --> 01:18:53,840
nine.

970
01:18:54,840 --> 01:18:57,520
So the total number of characters

971
01:18:58,080 --> 01:19:00,440
in this part which I am highlighting.

972
01:19:01,840 --> 01:19:05,480
27 You guys were counting it

973
01:19:05,480 --> 01:19:09,160
manually before.

974
01:19:09,160 --> 01:19:18,520
Yeah, we guys are very hardworking,
by the way, so

975
01:19:21,680 --> 01:19:24,440
if let's say I want to get

976
01:19:24,440 --> 01:19:28,920
the rest off the screen, if

977
01:19:29,920 --> 01:19:31,200
I want to get

978
01:19:31,200 --> 01:19:39,920
the rest of the string. Yes.

979
01:19:39,920 --> 01:19:43,880
So if I pass zero

980
01:19:45,600 --> 01:19:48,800
and five

981
01:19:49,320 --> 01:19:50,920
try to guess

982
01:19:51,320 --> 01:19:54,280
if zero is my starting position,

983
01:19:55,600 --> 01:19:57,680
five is my ending position

984
01:19:59,440 --> 01:20:01,640
work output,

985
01:20:01,640 --> 01:20:04,200
I will see

986
01:20:07,840 --> 01:20:18,440
a while.

987
01:20:18,440 --> 01:20:20,640
I don't see anything

988
01:20:20,920 --> 01:20:29,160
I would want.

989
01:20:29,160 --> 01:20:30,000
Exactly.

990
01:20:30,000 --> 01:20:32,040
I'm not printing it

991
01:20:35,160 --> 01:20:39,360
solid.

992
01:20:39,360 --> 01:20:47,440
I get feedback.

993
01:20:47,440 --> 01:20:48,280
Okay.

994
01:20:48,360 --> 01:20:55,640
And if I say let's say zero

995
01:20:58,840 --> 01:21:08,440
and 25 here,
we think I will be getting this first

996
01:21:08,480 --> 01:21:14,600
highlighted part.

997
01:21:14,600 --> 01:21:18,440
Yes, because my starting point is zero

998
01:21:20,160 --> 01:21:22,680
and my ending point is back.

999
01:21:23,120 --> 01:21:25,920
And if I do this,

1000
01:21:26,040 --> 01:21:28,040
if I do this,

1001
01:21:28,040 --> 01:21:31,440
if I make my starting point, I have six.

1002
01:21:31,440 --> 01:21:33,760
Let's see how many of you can guess it.

1003
01:21:33,760 --> 01:21:36,520
If my starting point is six

1004
01:21:37,360 --> 01:21:42,120
and my ending point is 25 plus,
tell me, will I see this badge?

1005
01:21:43,400 --> 01:21:47,120
Will I see this bad? No.

1006
01:21:48,320 --> 01:21:51,240
So you see how I am specifying the range?

1007
01:21:52,640 --> 01:21:56,560
How I am specifying the range
from that bigger screen.

1008
01:21:56,560 --> 01:22:02,320
And then I'm getting
whatever is present within that range.

1009
01:22:02,320 --> 01:22:05,120
So this is how the substring method works.

1010
01:22:05,840 --> 01:22:09,040
It requires you to pass a range,

1011
01:22:09,440 --> 01:22:13,200
basically a starting point
and ending point.

1012
01:22:14,000 --> 01:22:17,440
And from there the bigger string,
whatever is present

1013
01:22:17,520 --> 01:22:20,680
within that range,
it will give you that output

1014
01:22:22,400 --> 01:22:23,000
makes sense.

1015
01:22:23,000 --> 01:22:23,760
Is it easy?

1016
01:22:23,760 --> 01:22:28,800
Is it easy or hard?

1017
01:22:28,800 --> 01:22:31,360
It goes by index.

1018
01:22:31,680 --> 01:22:34,960
It counts dissipative as well.

1019
01:22:34,960 --> 01:22:37,000
It can't express it as well

1020
01:22:37,000 --> 01:22:42,160
because by index.

1021
01:22:42,160 --> 01:22:53,400
So let me push.

1022
01:22:53,400 --> 01:22:55,880
What do you use minus one here?

1023
01:22:56,920 --> 01:22:59,000
Is there any index or such

1024
01:22:59,000 --> 01:23:03,360
as minus one?

1025
01:23:03,360 --> 01:23:09,480
Do do indexes, do they exist in negative?

1026
01:23:09,480 --> 01:23:13,480
If I try to specify a negative
index, I will get a negative

1027
01:23:15,960 --> 01:23:18,240
string index out of bound.

1028
01:23:18,240 --> 01:23:19,520
Exception

1029
01:23:20,640 --> 01:23:30,240
indexes are always positive.

1030
01:23:30,240 --> 01:23:33,760
Is there a way we can tell
if we are starting or a negative space

1031
01:23:34,360 --> 01:23:36,840
besides the control we can tell.

1032
01:23:36,840 --> 01:23:39,480
Let me go over all the methods

1033
01:23:39,480 --> 01:23:43,480
and at the end,
by combining all of these methods,

1034
01:23:43,480 --> 01:23:54,280
you will be able
to do all kind of processing.

1035
01:23:54,280 --> 01:23:56,360
Okay, so let me do it again.

1036
01:23:56,360 --> 01:23:58,320
17 is a great bit.

1037
01:23:58,320 --> 01:24:02,040
Okay, Let's have a break now.

1038
01:24:02,040 --> 01:24:13,320
Time in which output
you are talking about.

1039
01:24:13,320 --> 01:24:15,520
Yes, that's correct. Six is included

1040
01:24:16,960 --> 01:24:21,240
and 25 is not.

1041
01:24:21,240 --> 01:24:24,240
How do you get this starting index fast?

1042
01:24:24,960 --> 01:24:26,760
You can select

1043
01:24:26,880 --> 01:24:29,560
that part and it will tell you

1044
01:24:29,560 --> 01:24:32,520
how many characters this part has.

1045
01:24:33,000 --> 01:24:51,800
And then you can skip those parts
by putting that number in.

1046
01:24:51,800 --> 01:24:54,280
Where are you automatically found?

1047
01:24:54,480 --> 01:24:55,640
It's so fun.

1048
01:24:57,040 --> 01:24:58,320
I'm not mad

1049
01:24:58,320 --> 01:25:00,880
in this anybody is not for

1050
01:25:02,880 --> 01:25:03,480
is it

1051
01:25:03,720 --> 01:25:09,280
for format. Okay

1052
01:25:22,840 --> 01:25:23,520
okay.

1053
01:25:23,960 --> 01:25:26,840
Output. Any questions wrong

1054
01:25:26,840 --> 01:25:32,880
from here?

1055
01:25:32,880 --> 01:25:35,640
Just asking you to simplify for me why

1056
01:25:36,040 --> 01:25:39,120
the dart is not printed.

1057
01:25:39,120 --> 01:25:43,200
Why the let's let's make it.

1058
01:25:43,200 --> 01:25:44,520
Let's do this.

1059
01:25:45,720 --> 01:25:49,600
Let's say we have four 0 to 4.

1060
01:25:51,000 --> 01:25:52,960
So this is how it works.

1061
01:25:52,960 --> 01:25:55,280
Everyone is here.
Can you give me a thumbs up? Right.

1062
01:25:55,280 --> 01:26:00,960
I would want it here
that I don't have to explain it again.

1063
01:26:00,960 --> 01:26:05,240
So this is how the substring
and generally every other method

1064
01:26:06,240 --> 01:26:09,160
is going to work.

1065
01:26:09,160 --> 01:26:11,400
The first value that we specify here,

1066
01:26:12,720 --> 01:26:16,520
whatever character is present
at this value

1067
01:26:17,880 --> 01:26:19,960
that will be included in the output,

1068
01:26:20,560 --> 01:26:23,440
but not this one.

1069
01:26:23,920 --> 01:26:26,680
For example, this for

1070
01:26:27,280 --> 01:26:29,320
the character that for is

1071
01:26:30,440 --> 01:26:31,160
B is are

1072
01:26:31,160 --> 01:26:37,440
208123 and four.

1073
01:26:37,920 --> 01:26:43,640
So the connector edge
the latter edge is present at index four.

1074
01:26:43,680 --> 01:26:46,920
Right Everyone

1075
01:26:47,120 --> 01:26:48,360
which character is presented

1076
01:26:48,360 --> 01:26:53,920
index world for edge
but that edge will not be printed.

1077
01:26:53,920 --> 01:26:56,880
It is not included in the output.

1078
01:26:56,880 --> 01:26:59,840
This starting index is inclusive.

1079
01:27:00,880 --> 01:27:03,480
This ending index is exclusive.

1080
01:27:04,720 --> 01:27:07,320
This is not included in the output here.

1081
01:27:07,360 --> 01:27:09,600
It is like less than

1082
01:27:10,920 --> 01:27:13,240
makes sense now and then.

1083
01:27:13,240 --> 01:27:15,840
Do you understand
now why this dart was not printed?

1084
01:27:16,920 --> 01:27:28,040
Because last characters are not included.

1085
01:27:28,040 --> 01:27:28,880
Okay.

1086
01:27:29,160 --> 01:27:35,240
Are you ready for a task?

1087
01:27:35,240 --> 01:27:58,320
Let me see if there are any tasks.

1088
01:27:58,320 --> 01:28:00,600
Okay, so this is the task for you.

1089
01:28:02,000 --> 01:28:05,520
You have to create a string
and just randomly store

1090
01:28:05,520 --> 01:28:08,280
anything inside that string.

1091
01:28:08,280 --> 01:28:11,920
And once the string is created,
you have to check

1092
01:28:12,600 --> 01:28:15,280
if the number of letters inside

1093
01:28:15,280 --> 01:28:18,600
that string, if they are odd, or even

1094
01:28:19,680 --> 01:28:21,880
if the number of letters are odd,

1095
01:28:23,560 --> 01:28:27,480
and if there are more than three

1096
01:28:28,880 --> 01:28:30,240
characters,

1097
01:28:30,960 --> 01:28:35,880
then you have to print
in the middle character from that string.

1098
01:28:35,880 --> 01:28:38,440
For example, if the string is hello,

1099
01:28:38,440 --> 01:28:40,880
the first thing you have to check
if it is even a rod.

1100
01:28:41,800 --> 01:28:44,360
So there is one, two,

1101
01:28:44,640 --> 01:28:47,240
three, four, five characters

1102
01:28:48,080 --> 01:28:50,800
present inside this string is five.

1103
01:28:50,800 --> 01:28:54,840
Even a rod.

1104
01:28:54,840 --> 01:28:56,400
It's odd.

1105
01:28:56,400 --> 01:28:58,800
So first condition is true

1106
01:28:58,800 --> 01:29:01,640
and are the number of letters

1107
01:29:01,760 --> 01:29:07,240
more than three or less?

1108
01:29:07,240 --> 01:29:09,600
More. So both conditions are true.

1109
01:29:09,880 --> 01:29:13,840
Number of letters plus the

1110
01:29:16,440 --> 01:29:17,920
all condition.

1111
01:29:17,920 --> 01:29:21,560
If both of these conditions are true,
you have to print this middle

1112
01:29:22,680 --> 01:29:24,000
editor.

1113
01:29:24,080 --> 01:29:27,240
This is the task.

1114
01:29:27,240 --> 01:29:33,560
Is the task clear to everyone?

1115
01:29:33,560 --> 01:29:34,160
Okay,

1116
01:29:35,240 --> 01:30:36,680
so please solve it.

1117
01:30:36,680 --> 01:30:55,680
You can ask questions
since the task is not clear.

1118
01:30:55,680 --> 01:30:56,160
Okay.

1119
01:30:56,160 --> 01:30:57,840
Which part you don't understand.

1120
01:30:57,840 --> 01:31:00,880
And it. No, no.

1121
01:31:00,880 --> 01:31:02,560
And don't wait to solve it.

1122
01:31:02,560 --> 01:31:05,760
Read the question,
understand it and solve it.

1123
01:31:07,080 --> 01:31:09,720
If you don't try, there is no way you

1124
01:31:09,960 --> 01:31:12,720
if you think you will be able to learn
that you are wrong.

1125
01:31:13,640 --> 01:31:15,320
We cannot learn like this.

1126
01:31:15,320 --> 01:31:16,480
We have to force their brain.

1127
01:31:16,480 --> 01:31:19,600
You have to think.

1128
01:31:19,600 --> 01:31:21,360
Tell me which line is not making sense.

1129
01:31:21,360 --> 01:31:22,160
Which which part?

1130
01:31:22,160 --> 01:32:08,000
Do not play. Uh,

1131
01:32:09,440 --> 01:32:12,080
is there any matter that can tell you

1132
01:32:12,720 --> 01:32:50,280
if a string is empty or not?

1133
01:32:50,280 --> 01:32:52,920
Yes, it's a very good code.

1134
01:32:52,920 --> 01:32:58,320
But remember,
you are trying to write be compact,

1135
01:32:58,680 --> 01:33:01,520
but you are not checking
for all the conditions

1136
01:33:03,560 --> 01:33:05,520
as per the requirement.

1137
01:33:05,520 --> 01:33:13,600
It's not good.

1138
01:33:13,600 --> 01:33:16,920
Yes, we have to write
the first condition. So

1139
01:33:18,840 --> 01:33:21,760
to follow all of the requirements

1140
01:34:11,040 --> 01:34:13,560
I counted first.

1141
01:34:13,560 --> 01:34:15,640
Yes, you have to count first.

1142
01:34:15,640 --> 01:34:18,960
If you don't count, you will not be able
to figure out if it's even or

1143
01:34:29,840 --> 01:34:30,840
by the way, those who are

1144
01:34:30,840 --> 01:34:33,520
done with the first one,
you can start working on the second one.

1145
01:34:35,040 --> 01:34:37,320
You have to print

1146
01:34:37,320 --> 01:36:09,840
a string in reverse order.

1147
01:36:09,840 --> 01:36:13,560
Instead, anyone who is still unable
to figure out what is going on here

1148
01:36:48,360 --> 01:36:51,240
Is there anyone also needs a hint

1149
01:36:51,240 --> 01:37:00,120
for the second part,

1150
01:37:00,120 --> 01:37:03,440
the hint is reverse loop

1151
01:37:04,840 --> 01:37:05,640
and no,

1152
01:37:05,640 --> 01:38:01,800
for the second part, reversals.

1153
01:38:01,800 --> 01:39:25,040
Okay.

1154
01:39:25,040 --> 01:39:27,600
Okay everyone, let's all this fuss far

1155
01:39:31,680 --> 01:39:54,480
and it with you.

1156
01:39:54,480 --> 01:39:57,240
Okay. So again, remember

1157
01:39:57,240 --> 01:40:00,040
in programing questions

1158
01:40:00,040 --> 01:40:04,840
breaking and breaking down the problem
in smaller steps

1159
01:40:05,360 --> 01:40:08,520
and then solving those smaller steps
one by one.

1160
01:40:09,080 --> 01:40:12,440
If the best approach, for example,

1161
01:40:13,240 --> 01:40:16,120
in the first part it says create a string.

1162
01:40:17,480 --> 01:40:22,560
So you can just focus only on this part
without even looking at the rest.

1163
01:40:23,080 --> 01:40:24,000
It's good.

1164
01:40:24,000 --> 01:40:24,720
It's very good

1165
01:40:24,720 --> 01:40:27,160
that you go through
the complete requirement once

1166
01:40:27,360 --> 01:40:29,240
so that you understand
the complete picture.

1167
01:40:29,240 --> 01:40:34,480
But then you, when you have to write
the code, you can go very

1168
01:40:35,520 --> 01:40:37,200
step by step,

1169
01:40:37,720 --> 01:40:38,760
one step at a time.

1170
01:40:38,760 --> 01:40:40,880
So create a string

1171
01:40:42,000 --> 01:40:44,360
so we can create a string

1172
01:40:49,360 --> 01:40:50,280
like this.

1173
01:40:50,280 --> 01:40:53,040
For example, any strings

1174
01:40:53,040 --> 01:40:55,280
here? The example is given for Hello.

1175
01:40:55,280 --> 01:40:58,440
So we can put the handle here

1176
01:40:58,920 --> 01:41:01,320
one one step at a time.

1177
01:41:01,320 --> 01:41:03,320
Now an expert

1178
01:41:03,320 --> 01:41:05,480
says if the string is not empty,

1179
01:41:06,600 --> 01:41:09,120
so this is the next step.

1180
01:41:09,120 --> 01:41:12,040
We want to make sure
that string is not empty.

1181
01:41:12,720 --> 01:41:19,240
How can we do this part?

1182
01:41:19,240 --> 01:41:22,880
How can we make sure
if a string is not empty?

1183
01:41:24,120 --> 01:41:27,000
We can use the example, the method

1184
01:41:27,320 --> 01:41:29,960
from this string class and

1185
01:41:31,680 --> 01:41:33,680
how this is empty method works.

1186
01:41:34,320 --> 01:41:38,360
It's going to return us a true
if the string is empty,

1187
01:41:39,200 --> 01:41:41,320
and if the string is not empty,

1188
01:41:41,440 --> 01:41:44,200
it's going to return as a false.

1189
01:41:44,880 --> 01:41:46,480
So we can say if

1190
01:41:48,600 --> 01:41:50,160
string

1191
01:41:51,280 --> 01:41:53,240
is empty

1192
01:41:53,240 --> 01:41:56,680
and we can put in note before folded,

1193
01:41:57,280 --> 01:42:00,120
which means if a string

1194
01:42:00,120 --> 01:42:07,160
is not empty.

1195
01:42:07,160 --> 01:42:09,840
So second step

1196
01:42:10,760 --> 01:42:13,080
next it says

1197
01:42:15,560 --> 01:42:16,080
If the string

1198
01:42:16,080 --> 01:42:19,600
is not emptied and perform the following

1199
01:42:19,600 --> 01:42:22,920
order,
we have to write more if conditions.

1200
01:42:22,920 --> 01:42:28,240
If string
has all the number of characters.

1201
01:42:28,800 --> 01:42:32,160
So now we need to figure out

1202
01:42:32,880 --> 01:42:33,680
if the number

1203
01:42:33,680 --> 01:42:36,280
of characters in a string or even a rod.

1204
01:42:37,200 --> 01:42:39,480
And before we can figure out
if it's even a rod,

1205
01:42:39,840 --> 01:42:44,160
we first need to know
the number characters in a string.

1206
01:42:44,640 --> 01:42:47,280
Is that any matter that can

1207
01:42:47,280 --> 01:42:49,440
give us the number of characters?

1208
01:42:50,920 --> 01:42:53,600
Exactly.

1209
01:42:53,600 --> 01:42:56,680
The name of the method is length.

1210
01:42:56,680 --> 01:42:58,800
We can say if

1211
01:42:58,960 --> 01:43:04,720
SDR and Lent this part, this piece

1212
01:43:05,760 --> 01:43:09,120
of code,
please give us the number of characters

1213
01:43:10,360 --> 01:43:12,080
and then

1214
01:43:12,080 --> 01:43:15,480
we can take the

1215
01:43:15,480 --> 01:43:17,480
remainder by two.

1216
01:43:18,120 --> 01:43:21,560
And if the remainder

1217
01:43:21,560 --> 01:43:24,440
is not equal to zero,

1218
01:43:25,680 --> 01:43:30,120
what does it mean
if the remainder is not equal to zero?

1219
01:43:30,120 --> 01:43:33,320
It means there's an odd

1220
01:43:33,320 --> 01:43:36,800
number.

1221
01:43:36,800 --> 01:43:38,840
So number of characters are odd

1222
01:43:40,360 --> 01:43:49,080
and we have to get further, further

1223
01:43:50,880 --> 01:43:54,800
and the number of characters
should be more than three

1224
01:43:55,960 --> 01:43:58,400
or three or more.

1225
01:43:58,400 --> 01:44:02,000
So should I put or condition here

1226
01:44:02,000 --> 01:44:04,240
or and continue

1227
01:44:10,080 --> 01:44:13,080
and condition

1228
01:44:13,280 --> 01:44:18,000
and SDR not Lent

1229
01:44:18,320 --> 01:44:23,560
is greater than or equal to three.

1230
01:44:23,560 --> 01:44:25,720
Now, some of you

1231
01:44:27,360 --> 01:44:29,400
might have gone my time gone.

1232
01:44:29,400 --> 01:44:30,840
One more step.

1233
01:44:30,840 --> 01:44:32,720
Tell me this goes

1234
01:44:34,280 --> 01:44:35,760
If a string

1235
01:44:35,760 --> 01:44:38,200
is having more than three characters,

1236
01:44:39,600 --> 01:44:42,520
is it possible that that string is empty?

1237
01:44:42,560 --> 01:44:45,080
Can can be empty

1238
01:44:45,200 --> 01:44:49,560
if the string has three character,
is it possible that it will be ever empty?

1239
01:44:50,640 --> 01:44:54,080
No. Then
do we need to write this condition?

1240
01:44:54,080 --> 01:44:54,600
Here?

1241
01:44:55,440 --> 01:44:57,080
I'll draw one

1242
01:44:58,560 --> 01:45:00,680
because this condition

1243
01:45:00,680 --> 01:45:04,000
is actually automatically being checked.

1244
01:45:04,040 --> 01:45:07,120
And here.

1245
01:45:07,120 --> 01:45:08,760
So that's how you can optimize your.

1246
01:45:08,760 --> 01:45:09,440
Could

1247
01:45:10,640 --> 01:45:12,680
this lend to greater than three?

1248
01:45:12,960 --> 01:45:17,400
It is also checking
if a string is not empty

1249
01:45:18,960 --> 01:45:23,000
the can this condition length
greater than three

1250
01:45:23,840 --> 01:45:26,400
it will only be true

1251
01:45:26,400 --> 01:45:28,560
if a string is not empty.

1252
01:45:28,560 --> 01:45:31,080
So what we can do, we can simplify output.

1253
01:45:32,240 --> 01:45:35,320
We can remove this part from here.

1254
01:45:35,320 --> 01:45:36,400
Is this point clear?

1255
01:45:36,400 --> 01:45:38,520
What I've just done in that clip?

1256
01:45:38,520 --> 01:46:01,040
Everyone.

1257
01:46:01,040 --> 01:46:01,920
Okay,

1258
01:46:02,640 --> 01:46:08,400
so next, next here, it's very simple.

1259
01:46:10,200 --> 01:46:11,800
We have to

1260
01:46:14,640 --> 01:46:23,360
we have to print the middle character.

1261
01:46:23,360 --> 01:46:27,520
So now how do I get the index

1262
01:46:27,520 --> 01:46:49,520
of middle character?

1263
01:46:49,520 --> 01:46:51,280
Exactly.

1264
01:46:51,280 --> 01:46:53,880
If there are all the number of characters,

1265
01:46:54,960 --> 01:46:57,240
if there are all the number of characters.

1266
01:46:57,240 --> 01:47:00,360
So for example,

1267
01:47:01,320 --> 01:47:04,080
if the number of characters are five,

1268
01:47:04,080 --> 01:47:15,600
if I divided by two, what time is it?

1269
01:47:15,600 --> 01:47:23,160
Will I get two or 2.5?

1270
01:47:23,160 --> 01:47:24,920
I mean, they're two

1271
01:47:25,320 --> 01:47:28,360
I will get to, you know, by

1272
01:47:28,360 --> 01:47:31,360
this this is an integer value.

1273
01:47:31,360 --> 01:47:33,960
Five is an integer, value

1274
01:47:33,960 --> 01:47:37,280
two is also an integer value

1275
01:47:37,640 --> 01:47:40,480
integer Dagger type

1276
01:47:40,480 --> 01:47:44,040
cannot hold the decimal part

1277
01:47:44,520 --> 01:47:47,800
in actual yes, the answer will be 2.5,

1278
01:47:48,520 --> 01:47:51,360
but because integers cannot hold
the decimal part,

1279
01:47:51,360 --> 01:47:53,520
this part will be ignored
and we would like to

1280
01:47:56,280 --> 01:47:59,720
and is to the middle.

1281
01:47:59,800 --> 01:48:02,440
Yes. Yes. Why?

1282
01:48:02,440 --> 01:48:06,000
Because index is the start from 0 to 0.

1283
01:48:06,120 --> 01:48:08,720
One, two,

1284
01:48:08,720 --> 01:48:10,400
three, four.

1285
01:48:11,080 --> 01:48:13,520
This is the middle character.

1286
01:48:13,520 --> 01:48:16,160
If there are total five,

1287
01:48:16,160 --> 01:48:20,760
the index for the middle
character is always one less.

1288
01:48:20,760 --> 01:48:22,920
Then remember index is the start from zero

1289
01:48:24,080 --> 01:48:26,440
so middle will always be one less than

1290
01:48:27,640 --> 01:48:29,760
the two here to here

1291
01:48:29,760 --> 01:48:33,080
and this will give us the middle.

1292
01:48:33,080 --> 01:48:36,000
So that's
why some of you might not understand.

1293
01:48:36,000 --> 01:48:39,400
But if you do this in the middle,

1294
01:48:40,360 --> 01:48:42,040
if you do this

1295
01:48:42,960 --> 01:48:45,240
SDR or not, and

1296
01:48:46,320 --> 01:48:49,360
divided by two,
you will get actually in the index

1297
01:48:49,360 --> 01:48:51,760
for the middle character

1298
01:48:52,400 --> 01:48:55,760
and then you can simply print it,

1299
01:48:56,000 --> 01:48:59,360
which method
I can use to get any specific element

1300
01:48:59,360 --> 01:49:26,080
at an index.

1301
01:49:26,080 --> 01:49:27,120
Exactly.

1302
01:49:27,120 --> 01:49:31,480
The method is SDR, dart, char add,

1303
01:49:33,000 --> 01:49:37,560
and then the index.

1304
01:49:37,560 --> 01:49:41,760
So that's how this code is working.

1305
01:49:41,760 --> 01:49:45,080
And and let's say

1306
01:49:46,040 --> 01:49:47,520
if I put only three

1307
01:49:47,520 --> 01:49:51,240
characters, lda

1308
01:49:55,480 --> 01:49:57,200
rejects for three characters,

1309
01:49:57,200 --> 01:49:59,640
not create indexes

1310
01:50:00,640 --> 01:50:03,080
is the length of this string

1311
01:50:03,680 --> 01:50:13,720
is three or more. Yes.

1312
01:50:13,720 --> 01:50:21,920
Are the number of characters or. Yes.

1313
01:50:22,960 --> 01:50:23,760
What is the land?

1314
01:50:23,760 --> 01:50:25,640
Lent is three

1315
01:50:26,320 --> 01:50:29,960
when this three will be divided
by two more to answer.

1316
01:50:29,960 --> 01:50:33,720
I believe that bond

1317
01:50:35,120 --> 01:50:38,520
and this is the index of listing.

1318
01:50:38,520 --> 01:50:47,160
So I'm gives.

1319
01:50:47,160 --> 01:51:16,880
Is there anyone who is still confused
about this part?

1320
01:51:16,880 --> 01:51:22,520
I'm going to remove the next example.

1321
01:51:22,520 --> 01:51:25,800
How many of you are still working

1322
01:51:25,800 --> 01:51:30,840
on the second part?

1323
01:51:30,840 --> 01:51:41,800
How many of you
are still working on the second part?

1324
01:51:41,800 --> 01:51:44,640
Okay, let me give you two more minutes.

1325
01:51:44,640 --> 01:51:48,200
Meanwhile, let me grab some water for me

1326
01:51:48,200 --> 01:55:26,720
and after 2 minutes
we will know this part again. And

1327
01:55:28,080 --> 01:55:39,440
but we have not discussed
the string builder yet.

1328
01:55:39,440 --> 01:55:44,280
How many of you are stuck or maybe think
this this is different or maybe hard

1329
01:55:45,640 --> 01:55:46,840
this in the second part

1330
01:55:56,880 --> 01:55:57,640
is your take.

1331
01:55:57,640 --> 01:56:16,880
Take your time.

1332
01:56:16,880 --> 01:56:19,840
Yeah, it's fine.

1333
01:56:19,840 --> 01:56:20,880
Anybody?

1334
01:56:20,880 --> 01:56:23,200
Why your home minister
is not in the picture

1335
01:56:24,320 --> 01:56:27,120
completely.

1336
01:56:27,120 --> 01:56:29,720
Does she know that you
this is what you did to her?

1337
01:56:29,920 --> 01:56:32,720
You cut her out out of the frame.

1338
01:56:34,560 --> 01:56:58,560
You don't love your life.

1339
01:56:58,560 --> 01:57:02,400
The only reason she took
this picture is so that she can tell

1340
01:57:03,320 --> 01:57:05,440
everyone that you are not.

1341
01:57:05,440 --> 01:57:07,720
You are already booked,
you are not available,

1342
01:57:09,120 --> 01:57:52,560
and you are doing the total opposite
of it.

1343
01:57:52,560 --> 01:59:40,920
You know, it's correct.

1344
01:59:40,920 --> 01:59:44,160
How many of you are still working on this

1345
01:59:56,880 --> 01:59:57,760
now? It's

1346
02:00:06,880 --> 02:00:27,120
You guys look great. Now

1347
02:00:28,440 --> 02:01:10,640
let's do this one.

1348
02:01:10,640 --> 02:01:12,400
Okay, So.

1349
02:01:12,400 --> 02:01:14,840
Oh, by the way, this question,

1350
02:01:15,360 --> 02:01:17,520
it's a very famous interview
question as well.

1351
02:01:18,720 --> 02:01:22,400
They give you a string
and then they ask you to reverse it.

1352
02:01:23,760 --> 02:01:24,720
Yes. Sometimes

1353
02:01:24,720 --> 02:01:27,480
they give you an array
and ask to reverse it.

1354
02:01:28,520 --> 02:01:32,880
So it's just a very famous interview
question.

1355
02:01:32,880 --> 02:01:35,880
Okay, Let's say we have a string PR

1356
02:01:37,360 --> 02:01:42,720
and then we have a string inside it,

1357
02:01:42,720 --> 02:01:45,160
and then you have to reverse it
and then print it.

1358
02:01:46,080 --> 02:01:49,400
So it's very simple.

1359
02:01:50,000 --> 02:01:52,160
You can simply reverse it

1360
02:01:53,960 --> 02:01:56,080
and then you can print it.

1361
02:01:57,520 --> 02:02:00,960
No, you guys don't like my solution

1362
02:02:01,720 --> 02:02:08,680
If I'm the perfect output.

1363
02:02:08,680 --> 02:02:13,920
Yeah, you can do that in the interview
as well. If.

1364
02:02:14,640 --> 02:02:17,120
Okay,
maybe some of you don't agree with me.

1365
02:02:17,400 --> 02:02:19,760
So there going to be

1366
02:02:19,760 --> 02:02:21,360
under a little bit.

1367
02:02:21,360 --> 02:02:21,960
I'm just kidding.

1368
02:02:21,960 --> 02:02:29,760
This is not to do it
and this is not what they mean.

1369
02:02:29,760 --> 02:02:33,400
So you can always start a reverse loop

1370
02:02:34,080 --> 02:02:36,960
and then you can start grabbing the

1371
02:02:38,040 --> 02:02:40,200
elements from the end one by one.

1372
02:02:40,200 --> 02:02:44,040
So let's say you have this loop

1373
02:02:46,080 --> 02:02:48,240
that I want to start from

1374
02:02:49,520 --> 02:02:53,800
zero, and then I want to go tail

1375
02:02:53,840 --> 02:03:00,800
the last character.

1376
02:03:00,800 --> 02:03:06,000
So what is the what is the index

1377
02:03:06,200 --> 02:03:11,160
of the last element?

1378
02:03:11,160 --> 02:03:13,280
SDR Client

1379
02:03:22,320 --> 02:03:26,680
So the last index, if I put SDR

1380
02:03:26,680 --> 02:03:31,080
DART length, will it work
or I will be getting in at it?

1381
02:03:31,080 --> 02:03:33,600
I'm asking about the last index.

1382
02:03:33,600 --> 02:03:37,920
NORDLAND Last index.

1383
02:03:37,920 --> 02:03:40,400
Last index is always,

1384
02:03:41,640 --> 02:03:44,720
always one less than the length.

1385
02:03:45,960 --> 02:03:47,040
Last index.

1386
02:03:47,040 --> 02:03:50,400
Let me repeat, last index is always one

1387
02:03:51,000 --> 02:03:53,280
less than the length.

1388
02:03:53,800 --> 02:03:55,800
So we have to subtract one

1389
02:03:57,160 --> 02:04:00,240
and now it will give me the last index,

1390
02:04:00,240 --> 02:04:02,640
the index of this. Why

1391
02:04:04,080 --> 02:04:06,760
And then this condition.

1392
02:04:06,760 --> 02:04:09,160
I want to go

1393
02:04:09,160 --> 02:04:13,920
till this character,
which is present at index zero

1394
02:04:15,800 --> 02:04:18,960
so I can see

1395
02:04:18,960 --> 02:04:21,800
I greater than equal to zero.

1396
02:04:21,960 --> 02:04:27,080
I want to go as long as I is

1397
02:04:27,080 --> 02:04:29,600
greater or equal to zero.

1398
02:04:31,440 --> 02:04:33,120
And because we

1399
02:04:33,720 --> 02:04:35,920
going in the reverse direction,

1400
02:04:35,920 --> 02:04:39,640
we see minus one what happens.

1401
02:04:39,640 --> 02:04:41,600
Without minus one, I would do one.

1402
02:04:41,600 --> 02:04:44,480
What will happen without minus one

1403
02:04:52,640 --> 02:04:53,880
out of bounds.

1404
02:04:53,880 --> 02:04:56,280
We will be getting index out of bound

1405
02:05:00,280 --> 02:05:02,200
now which method I can use

1406
02:05:02,200 --> 02:05:07,000
to grab the characters at these indexes

1407
02:05:09,000 --> 02:05:10,320
chart. Right.

1408
02:05:10,320 --> 02:05:14,680
So if I see SDR dart chart Act,

1409
02:05:14,920 --> 02:05:23,240
I, and if I run it,

1410
02:05:23,240 --> 02:05:25,440
I get all the characters.

1411
02:05:26,640 --> 02:05:30,560
But every character
is being printed on a separate

1412
02:05:30,880 --> 02:05:36,280
How can I fix this?

1413
02:05:36,280 --> 02:05:38,920
Remove all the elements

1414
02:05:39,840 --> 02:05:42,720
and only use the print

1415
02:05:43,440 --> 02:05:47,000
and then means new line.

1416
02:05:47,000 --> 02:05:52,200
So that's how we will be able
to get to the output in the reverse order.

1417
02:05:52,840 --> 02:05:57,720
How many of you still don't understand
how we are able to reverse the letters

1418
02:06:08,280 --> 02:06:10,320
yet? I mean, it's a very small thing,

1419
02:06:11,040 --> 02:06:16,520
whether you put it
horizontally or vertically.

1420
02:06:16,520 --> 02:06:20,800
So I am assuming you do not need
this reversed.

1421
02:06:21,120 --> 02:06:24,320
You can do that as well. That as well.

1422
02:06:24,320 --> 02:06:25,320
Like for

1423
02:06:26,400 --> 02:06:29,120
instead of printing here,

1424
02:06:29,120 --> 02:06:35,000
you can create another string variable,
reverse string,

1425
02:06:36,440 --> 02:06:38,160
and you can initialize it

1426
02:06:38,160 --> 02:06:41,320
with empty string initially.

1427
02:06:41,320 --> 02:06:43,560
And then instead
of printing these characters,

1428
02:06:44,240 --> 02:06:46,320
you can append

1429
02:06:47,400 --> 02:06:49,480
reverse and string is equal to reverse

1430
02:06:49,480 --> 02:06:51,840
suspend plus

1431
02:06:53,720 --> 02:06:56,240
you can append all of these characters

1432
02:06:56,240 --> 02:07:00,120
one by one in the reverse manner,
and then at the end

1433
02:07:00,120 --> 02:07:13,040
you can bring them.

1434
02:07:13,040 --> 02:07:16,360
So when some of you have done this,
this is also a good excuse.

1435
02:07:16,400 --> 02:07:18,040
This one is better.

1436
02:07:18,040 --> 02:07:20,600
This it is first time
you've changed before.

1437
02:07:20,600 --> 02:07:22,280
Look format.

1438
02:07:22,280 --> 02:07:24,880
No, no, no. We have done this many times.

1439
02:07:24,880 --> 02:07:28,720
Every one Did we write the loop already?

1440
02:07:28,720 --> 02:07:31,120
Many times
when we were practicing the loops.

1441
02:07:32,280 --> 02:07:34,280
Yes. So

1442
02:07:34,280 --> 02:07:41,640
maybe you have missed that part.

1443
02:07:41,640 --> 02:07:43,640
Okay, let's debug this code.

1444
02:07:43,640 --> 02:07:46,560
How many of you want me to debug

1445
02:07:59,040 --> 02:08:00,400
this note

1446
02:08:00,400 --> 02:08:07,080
here?

1447
02:08:07,080 --> 02:08:07,480
Okay.

1448
02:08:07,680 --> 02:08:12,680
So we have an empty variable.

1449
02:08:12,680 --> 02:08:17,040
If it is not reversing,
can we use extended loop

1450
02:08:17,480 --> 02:08:19,480
for calling the elements of a string

1451
02:08:21,440 --> 02:08:22,800
first? Why?

1452
02:08:22,800 --> 02:08:24,960
It will not reverse.
It will always reverse.

1453
02:08:25,800 --> 02:08:28,840
And second,
what do you mean by extended loop?

1454
02:08:29,080 --> 02:08:32,320
Do you mean enhanced loop?

1455
02:08:32,320 --> 02:08:34,040
If you use enhanced loop,

1456
02:08:34,040 --> 02:08:36,320
remember
you can not go into reverse detection

1457
02:08:36,720 --> 02:08:44,200
using the enhanced loop.

1458
02:08:44,200 --> 02:08:47,040
Enhanced loop cannot be used.
Nice. Can we?

1459
02:08:47,480 --> 02:08:51,000
Can we go in the reverse fashion using

1460
02:08:51,000 --> 02:08:56,600
the enhanced?

1461
02:08:56,600 --> 02:08:59,520
This was one of the limitations
of enhanced loop.

1462
02:09:00,160 --> 02:09:01,760
We cannot go reverse.

1463
02:09:01,760 --> 02:09:04,320
We cannot access elements.

1464
02:09:04,320 --> 02:09:05,880
And this was one of the limitations

1465
02:09:07,920 --> 02:09:10,280
of the so

1466
02:09:12,320 --> 02:09:14,000
initially

1467
02:09:15,120 --> 02:09:17,320
this PR dark land.

1468
02:09:18,760 --> 02:09:21,120
Oh, by the way, I don't I don't think so.

1469
02:09:21,120 --> 02:09:27,120
If I have shown you during the debugging,
if you want to look individual,

1470
02:09:28,000 --> 02:09:30,280
if you want to look at the output

1471
02:09:30,280 --> 02:09:34,240
of individual pieces of all,
you can also do that.

1472
02:09:34,240 --> 02:09:38,520
For example, if you first want to know
what this estimate

1473
02:09:38,520 --> 02:09:42,200
or client is going to return,
you can select this part

1474
02:09:45,200 --> 02:09:45,960
and you can click

1475
02:09:45,960 --> 02:09:48,120
on this evaluate expression button here,

1476
02:09:49,200 --> 02:09:50,280
this, this.

1477
02:09:50,280 --> 02:09:53,520
It looks like a calculator.

1478
02:09:53,520 --> 02:09:56,240
You can click on this.

1479
02:09:56,240 --> 02:09:58,360
Then it will open this window
in front of you

1480
02:09:59,640 --> 02:10:03,800
in which you can write any piece of code
from here, from this line,

1481
02:10:04,840 --> 02:10:06,240
and it will give you answer.

1482
02:10:06,240 --> 02:10:07,920
For example, if I click on Evaluate,

1483
02:10:09,000 --> 02:10:10,920
it is telling me

1484
02:10:19,760 --> 02:10:20,640
it is telling me

1485
02:10:20,640 --> 02:10:24,360
that SDR total Lent
is going to return six,

1486
02:10:25,320 --> 02:10:27,400
then you can also write minus one

1487
02:10:28,880 --> 02:10:31,840
and then it will tell you
that this will give you five.

1488
02:10:32,760 --> 02:10:35,600
You can also write

1489
02:10:35,600 --> 02:10:40,440
SDR Dart Char ad and you can put five here

1490
02:10:41,960 --> 02:10:44,360
and it will tell you that it will it is

1491
02:10:44,360 --> 02:10:47,360
going to just going to return y.

1492
02:10:47,360 --> 02:10:50,480
So if you want, even if you want to go

1493
02:10:50,480 --> 02:10:54,120
even in these teeny tiny details, it's

1494
02:10:54,360 --> 02:10:56,680
it's completely possible

1495
02:10:58,240 --> 02:11:00,480
using evaluate expression,

1496
02:11:00,480 --> 02:11:09,680
but it only works during debugging.

1497
02:11:09,680 --> 02:11:13,160
You read my mind. Yeah.

1498
02:11:13,160 --> 02:11:17,000
So SDR Land is going to return six,

1499
02:11:17,640 --> 02:11:20,480
then we subtract one from that.

1500
02:11:20,600 --> 02:11:22,920
It will give us five.

1501
02:11:22,920 --> 02:11:25,360
Then this condition will be checked.

1502
02:11:25,360 --> 02:11:28,000
Is a five greater than equal

1503
02:11:28,000 --> 02:11:32,400
to zero? Yes.

1504
02:11:32,840 --> 02:11:35,880
If the condition
is true, we enter the loop

1505
02:11:37,800 --> 02:11:41,080
and then again we have multiple pieces

1506
02:11:42,280 --> 02:11:42,920
here.

1507
02:11:42,920 --> 02:11:45,720
One piece, this one SDR shot

1508
02:11:45,840 --> 02:11:51,720
and it is fetching the character
at this index.

1509
02:11:51,720 --> 02:11:55,800
I the value of I right now is five

1510
02:11:57,560 --> 02:12:00,040
this park SDR shot ad

1511
02:12:00,880 --> 02:12:04,560
If you want to see where this part is
going to do, you can again evaluate

1512
02:12:05,480 --> 02:12:07,560
SDR or chart and I

1513
02:12:07,920 --> 02:12:10,920
will give you the letter Y.

1514
02:12:10,920 --> 02:12:14,160
Then you are saying then you are doing

1515
02:12:16,880 --> 02:12:18,800
reversed

1516
02:12:18,920 --> 02:12:19,880
plus.

1517
02:12:20,640 --> 02:12:23,080
So after returning Y

1518
02:12:24,040 --> 02:12:26,440
you can see it will get appended

1519
02:12:27,680 --> 02:12:32,600
to the string reversed
and the result will become y.

1520
02:12:33,000 --> 02:12:38,400
So even if you want to see each and every
step, well, whatever Janhvi is doing,

1521
02:12:38,800 --> 02:12:41,520
you can go into all of those details
using this

1522
02:12:42,240 --> 02:12:44,760
evaluate expression

1523
02:12:45,200 --> 02:12:46,640
and it's very helpful in debugging

1524
02:12:46,640 --> 02:13:03,440
complex course.

1525
02:13:03,440 --> 02:13:04,880
You did not get my question.

1526
02:13:04,880 --> 02:13:08,520
If we just want to pull the
elements of a string forward

1527
02:13:10,080 --> 02:13:11,880
and we use

1528
02:13:11,880 --> 02:13:15,920
enhanced loop instead of no enhanced

1529
02:13:15,920 --> 02:13:19,200
loop only works with arrays

1530
02:13:24,840 --> 02:13:28,400
and hence loop only works with arrays.

1531
02:13:28,680 --> 02:13:32,480
There are other data structures
that we will learn later on.

1532
02:13:32,640 --> 02:13:35,040
It can work with those as well.

1533
02:13:35,040 --> 02:13:37,680
So in this case, you have to

1534
02:13:38,120 --> 02:13:42,280
you actually have one or only one option,
and the option is

1535
02:13:42,680 --> 02:13:45,200
you first convert this string

1536
02:13:45,960 --> 02:13:48,680
to an array of characters

1537
02:13:50,080 --> 02:13:54,160
and once you have an array of characters,
then you can use the enhanced for,

1538
02:13:54,640 --> 02:14:01,920
Oh, by the way,
I want to show you that part.

1539
02:14:01,920 --> 02:14:07,360
What is the difference between printing
SDR DART chart?

1540
02:14:07,400 --> 02:14:10,560
It and then printing reverse? Nothing.

1541
02:14:10,880 --> 02:14:13,680
Here we are fast restoring

1542
02:14:13,680 --> 02:14:17,600
the output in a variable
and then printing it.

1543
02:14:17,600 --> 02:14:21,840
So output will not change.

1544
02:14:21,840 --> 02:14:25,920
So reversed plus SDR dart chart.

1545
02:14:26,920 --> 02:14:30,000
So keep an eye on this value of reversed

1546
02:14:31,480 --> 02:14:32,040
or non.

1547
02:14:32,040 --> 02:14:35,000
Then I would ask you to debug discord.

1548
02:14:35,000 --> 02:14:36,440
I don't think say one.

1549
02:14:36,440 --> 02:14:38,720
They will be allowing you
to use intelligent.

1550
02:14:39,480 --> 02:14:41,240
Most of the time.

1551
02:14:41,240 --> 02:14:46,000
These coding questions
which are given during the interview.

1552
02:14:46,920 --> 02:14:50,040
They will be on rapid or something
similar to that but

1553
02:14:51,560 --> 02:14:55,800
they will be sharing the link of a website
which will look very similar to Ripple.

1554
02:14:56,640 --> 02:14:58,960
And there you will solve the question

1555
02:14:59,400 --> 02:15:02,480
and your search to be
whatever you will be typing here.

1556
02:15:02,480 --> 02:15:04,560
They will also be able to see
on the other end

1557
02:15:07,960 --> 02:15:08,440
famous

1558
02:15:08,440 --> 02:15:13,080
platforms are occurring or they could be

1559
02:15:14,320 --> 02:15:17,720
called signal.

1560
02:15:17,720 --> 02:15:22,080
So these are the platforms that are used.

1561
02:15:22,080 --> 02:15:25,920
Yes, you will be able to.

1562
02:15:25,920 --> 02:15:30,960
So they see your mistakes
and figuring it out. Yes.

1563
02:15:30,960 --> 02:15:44,200
Yeah.

1564
02:15:44,200 --> 02:15:48,320
A big So next we get the

1565
02:15:49,200 --> 02:15:53,200
next element, which is

1566
02:15:54,320 --> 02:15:56,320
the tell your friend

1567
02:15:56,320 --> 02:16:03,120
that no, it's not allowed,
It's not possible.

1568
02:16:03,120 --> 02:16:05,280
So the next

1569
02:16:05,280 --> 02:16:07,560
the value of AI will decrease by one.

1570
02:16:08,600 --> 02:16:12,160
So it will be for and then it will grab

1571
02:16:12,200 --> 02:16:15,360
the element of the next four
and then it will append it with y.

1572
02:16:16,880 --> 02:16:22,160
So y e is The character at index four

1573
02:16:22,880 --> 02:16:25,200
will get appended with the letter y,

1574
02:16:26,640 --> 02:16:29,000
then the value of AI will further decrease

1575
02:16:29,000 --> 02:16:31,480
by one, making it three.

1576
02:16:32,680 --> 02:16:35,920
Then the element of index three which is D

1577
02:16:37,080 --> 02:16:38,760
will be grabbed

1578
02:16:39,880 --> 02:16:41,560
and then it will be appended

1579
02:16:41,560 --> 02:16:44,720
with this reverse string.

1580
02:16:44,720 --> 02:16:49,200
And slowly
we will keep on grabbing the elements

1581
02:16:49,200 --> 02:16:52,440
in the reverse fashion
and keep on appending goodness.

1582
02:16:52,440 --> 02:17:14,520
Reverse the string.

1583
02:17:14,520 --> 02:17:17,040
I have a friend who works on

1584
02:17:18,160 --> 02:17:20,840
I.t Company for two and a half years.

1585
02:17:20,840 --> 02:17:21,800
He could not create

1586
02:17:23,400 --> 02:17:26,040
for some tasks

1587
02:17:28,080 --> 02:17:30,000
we are solving

1588
02:17:30,800 --> 02:17:34,080
here.

1589
02:17:34,080 --> 02:17:37,800
Coding is not for everyone.

1590
02:17:37,800 --> 02:17:39,360
Okay, everyone.

1591
02:17:39,360 --> 02:17:42,400
So now we can do ask.

1592
02:17:42,760 --> 02:17:46,000
Can we use hand if we create it? Yes.

1593
02:17:46,040 --> 02:17:48,680
Then we can.

1594
02:17:48,680 --> 02:17:51,560
Yes, then we can.

1595
02:17:51,560 --> 02:17:55,320
And it's totally possible
he might be working as a man.

1596
02:17:55,320 --> 02:17:56,520
We're desperate

1597
02:17:57,080 --> 02:17:59,800
and automation is not the first thing
companies do.

1598
02:17:59,920 --> 02:18:02,280
They are always best do things manually

1599
02:18:03,120 --> 02:18:05,920
and once they see
something is being repeated again

1600
02:18:05,920 --> 02:18:24,080
and again and it is taking a lot of time,
then only the automated.

1601
02:18:24,080 --> 02:18:29,880
So he's actually paying for
or staying in that company.

1602
02:18:29,880 --> 02:18:30,800
Okay.

1603
02:18:30,800 --> 02:18:33,400
Mikail for opening

1604
02:18:33,400 --> 02:18:36,640
the evaluate expression window,
you need to be in debug point

1605
02:18:37,440 --> 02:18:40,920
and once you are in debug point, select
any part of the code

1606
02:18:42,080 --> 02:18:43,520
and then you can click on this button

1607
02:18:51,360 --> 02:18:54,000
here.

1608
02:18:54,000 --> 02:18:59,560
So then we have one more question.

1609
02:18:59,560 --> 02:19:02,920
This one is formatted once,

1610
02:19:02,920 --> 02:19:05,040
so you have to create a program

1611
02:19:06,840 --> 02:19:10,000
which will ask to be first of mom

1612
02:19:11,360 --> 02:19:14,480
and the first name of Dad.

1613
02:19:14,480 --> 02:19:16,960
And if they are expecting a boy or girl

1614
02:19:18,240 --> 02:19:20,920
and then it will suggest
the name for the baby

1615
02:19:23,280 --> 02:19:27,400
and this is how it is going to work.

1616
02:19:27,400 --> 02:19:29,400
If the if they are expecting a girl,

1617
02:19:30,480 --> 02:19:35,520
it will take the first 50% characters
plus two half

1618
02:19:36,600 --> 02:19:38,760
from the name of the mother

1619
02:19:39,720 --> 02:19:43,320
and second half
from the name of the father.

1620
02:19:44,280 --> 02:19:45,200
For example.

1621
02:19:45,200 --> 02:19:48,080
If they are expecting boy.

1622
02:19:48,080 --> 02:19:51,840
So program has taken
first of three characters

1623
02:19:53,160 --> 02:19:55,760
from the name of Father

1624
02:19:55,760 --> 02:19:59,760
and, last two characters
from Name of Mother,

1625
02:19:59,760 --> 02:20:03,040
and then it suggested the name Dante.

1626
02:20:03,760 --> 02:20:05,000
So in the case of Y

1627
02:20:06,000 --> 02:20:07,320
plus, two half

1628
02:20:07,320 --> 02:20:10,680
of Father and second half of the mother,

1629
02:20:11,440 --> 02:20:15,600
in the case of a girl,
plus two half from the mother's name

1630
02:20:16,600 --> 02:20:19,040
and the second half
from the father's name.

1631
02:20:20,800 --> 02:20:21,840
And then

1632
02:20:22,360 --> 02:20:24,840
to suggest the name,

1633
02:20:24,840 --> 02:20:28,680
what, just a girl to not worry about it.

1634
02:20:28,800 --> 02:20:35,400
We don't have to name
other things like this.

1635
02:20:35,400 --> 02:20:38,320
Okay, so this is your homework.

1636
02:20:38,320 --> 02:20:41,520
Let me give you this as your homework

1637
02:20:41,840 --> 02:20:42,800
from the part.

1638
02:20:42,800 --> 02:20:45,880
It means if there are six character
in the name of Mother

1639
02:20:46,320 --> 02:20:54,280
plus the three characters will be taken.

1640
02:20:54,280 --> 02:21:00,560
Even more examples.

1641
02:21:00,560 --> 02:21:02,400
For example, look here.

1642
02:21:03,320 --> 02:21:09,960
Okay, Don't worry, Madina, you are lost.

1643
02:21:09,960 --> 02:21:13,440
Let's take the example from Madina.

1644
02:21:13,520 --> 02:21:15,120
Where is after

1645
02:21:17,600 --> 02:21:20,080
again?

1646
02:21:20,080 --> 02:21:23,840
So let's say these guys,
they are expecting a boy

1647
02:21:25,960 --> 02:21:27,600
and they are expecting a boy.

1648
02:21:27,600 --> 02:21:29,520
Plus two half of the

1649
02:21:30,680 --> 02:21:32,880
father is going to be

1650
02:21:33,680 --> 02:21:36,840
taken in the case Y ERP.

1651
02:21:37,760 --> 02:21:40,360
And then second half

1652
02:21:40,360 --> 02:21:42,600
in the case of Mother,

1653
02:21:42,920 --> 02:21:46,920
and here is the name
for your boy, our DNA,

1654
02:21:46,960 --> 02:21:51,280
although it looks more like a female name,
but this is

1655
02:21:51,920 --> 02:22:03,440
our programing is working.

1656
02:22:03,440 --> 02:22:05,360
And let's see

1657
02:22:05,400 --> 02:22:09,400
if the parents are expecting a girl then.

1658
02:22:09,920 --> 02:22:13,120
So first half of the mother's name

1659
02:22:15,120 --> 02:22:17,840
and then second half of P

1660
02:22:18,520 --> 02:22:22,360
from the father's name. Yes.

1661
02:22:22,400 --> 02:22:25,480
So in the program, search
suggest this name

1662
02:22:26,280 --> 02:22:30,400
if they're expecting it.

1663
02:22:30,400 --> 02:22:32,680
Very well.

1664
02:22:32,840 --> 02:22:41,720
See the here and okay,
we have Aisha and I'll be right.

1665
02:22:42,160 --> 02:22:44,560
So names can be

1666
02:22:46,200 --> 02:22:51,000
all the numbers and even numbers.

1667
02:22:51,000 --> 02:22:54,680
So, for example,
if they're expecting a boy

1668
02:22:56,000 --> 02:22:58,720
will take the first half.

1669
02:22:58,720 --> 02:23:03,400
So what what will be the first
half in this case?

1670
02:23:03,400 --> 02:23:03,760
Okay.

1671
02:23:06,800 --> 02:23:10,680
So first half

1672
02:23:11,720 --> 02:23:14,200
from here and

1673
02:23:15,480 --> 02:23:18,000
second half

1674
02:23:20,760 --> 02:23:23,440
or her warning is going to be

1675
02:23:31,680 --> 02:23:35,400
and in the case of the

1676
02:23:37,200 --> 02:23:39,320
first half from the mother's name

1677
02:23:40,320 --> 02:23:43,680
and second half from the father's

1678
02:23:43,680 --> 02:23:48,360
name,

1679
02:23:48,360 --> 02:23:53,120
your family looks very funny.

1680
02:23:53,120 --> 02:23:55,320
Like, who else in here

1681
02:24:05,040 --> 02:24:07,240
from where you get this idea,

1682
02:24:07,240 --> 02:24:10,720
If just more intelligent brain, you know,

1683
02:24:11,040 --> 02:24:17,880
extra ordinary idea always.

1684
02:24:17,880 --> 02:24:21,520
You see those love calculators
or other things on online.

1685
02:24:21,600 --> 02:24:25,280
They're all working like this.

1686
02:24:25,280 --> 02:24:30,680
And no, don't worry,
I will solve it with you Next class. Yes.

1687
02:24:30,680 --> 02:24:34,680
For in the case of why first half
from the father's name and the second half

1688
02:24:34,680 --> 02:24:41,760
from others, again,

1689
02:24:41,760 --> 02:24:48,680
I have shared the question in the course
announcement.

1690
02:24:48,680 --> 02:24:50,320
You can use Canada if you want.

1691
02:24:50,320 --> 02:24:59,800
Yes. Okay.

1692
02:25:00,360 --> 02:25:03,560
So next is again, a very simple letter

1693
02:25:07,760 --> 02:25:09,280
in don't to use here.

1694
02:25:09,280 --> 02:25:12,680
You can ignore it.

1695
02:25:12,680 --> 02:25:16,440
Next method is very simple.

1696
02:25:16,440 --> 02:25:27,840
Let me create.

1697
02:25:27,840 --> 02:25:29,960
Okay. And please don't share this piece

1698
02:25:29,960 --> 02:25:33,920
of incredible piece of logic
with your relatives.

1699
02:25:33,920 --> 02:25:37,480
And don't tell them that you have created
very good, which can

1700
02:25:38,600 --> 02:25:42,440
relate or which can tell you
the names of the babies

1701
02:25:43,680 --> 02:25:45,840
based on the names
of their mother, father,

1702
02:25:46,920 --> 02:25:48,280
and whom

1703
02:25:54,480 --> 02:25:57,480
a next method is very simple, very easy.

1704
02:25:58,520 --> 02:26:01,520
And it's actually most useful, most widely

1705
02:26:01,520 --> 02:26:04,520
used method in the string class.

1706
02:26:04,520 --> 02:26:06,200
Let's imagine

1707
02:26:07,160 --> 02:26:09,720
if we have a string

1708
02:26:15,600 --> 02:26:17,200
that has a string

1709
02:26:19,720 --> 02:26:20,280
and let's say

1710
02:26:20,280 --> 02:26:23,600
you want to replace something
from this string.

1711
02:26:23,600 --> 02:26:28,320
Let's say
you want to replace this word with great.

1712
02:26:28,320 --> 02:26:31,080
So what you can do,
you can use the replacement part

1713
02:26:32,560 --> 02:26:35,920
to string new SDR

1714
02:26:37,360 --> 02:26:38,480
and the method name.

1715
02:26:38,480 --> 02:26:40,160
Can you guess the name of the method?

1716
02:26:40,160 --> 02:26:42,560
I want to replace the good with great

1717
02:26:43,680 --> 02:26:45,000
from the string class.

1718
02:26:45,000 --> 02:27:03,600
Can you guess the name of the matter?

1719
02:27:03,600 --> 02:27:09,320
The method is called Replace.

1720
02:27:09,320 --> 02:27:12,240
So it takes two

1721
02:27:12,240 --> 02:27:14,440
arguments, two values

1722
02:27:14,440 --> 02:27:18,480
plus is the screen
that you want to replace.

1723
02:27:18,480 --> 02:27:20,360
So in our case, we want replace.

1724
02:27:20,360 --> 02:27:21,000
Good.

1725
02:27:22,400 --> 02:27:23,840
And the second is

1726
02:27:23,840 --> 02:27:26,680
we do what you want to replace it

1727
02:27:27,760 --> 02:27:31,080
so you can say, great.

1728
02:27:31,200 --> 02:27:33,240
So wherever

1729
02:27:33,240 --> 02:27:35,720
in this string, wherever

1730
02:27:35,720 --> 02:27:38,720
the good keyword is present,

1731
02:27:40,240 --> 02:27:44,040
everywhere, it will be replaced
with the great keyword.

1732
02:27:45,480 --> 02:27:48,600
Then print out

1733
02:27:49,240 --> 02:27:57,240
this newest deal.

1734
02:27:57,240 --> 02:28:00,160
So the output will say Best 17 is great.

1735
02:28:01,200 --> 02:28:04,000
Try it on end right screen

1736
02:28:04,560 --> 02:28:22,000
and then try to replace something
from that string. Yep.

1737
02:28:22,480 --> 02:28:26,680
And this is the function
that you use basically in your word Excel.

1738
02:28:27,240 --> 02:28:30,000
I'm sure you have seen it in your editor

1739
02:28:30,040 --> 02:28:36,680
as well.

1740
02:28:36,680 --> 02:28:39,240
They extend it as they use it a lot.

1741
02:28:40,960 --> 02:28:42,760
Usually the shortcut is control F

1742
02:28:42,760 --> 02:28:59,400
or something like this. Yes.

1743
02:29:01,440 --> 02:29:02,760
So it's very simple.

1744
02:29:02,760 --> 02:29:05,080
And if there are multiple

1745
02:29:13,680 --> 02:29:17,160
if if the keyword is present
multiple times,

1746
02:29:18,240 --> 02:29:20,920
it will be replaced everywhere.

1747
02:29:21,400 --> 02:29:24,080
So this code and this word both

1748
02:29:24,080 --> 02:29:33,640
will be replaced.

1749
02:29:33,640 --> 02:29:35,760
So by 17 is great.

1750
02:29:35,800 --> 02:29:39,240
They are doing great.

1751
02:29:39,240 --> 02:29:42,440
And one more thing, if I put uppercase G,

1752
02:29:43,520 --> 02:29:48,840
do you think it will work?

1753
02:29:48,840 --> 02:29:51,240
No, because Java is a sensitive flip.

1754
02:29:51,240 --> 02:29:59,520
This is not going to work.

1755
02:29:59,520 --> 02:30:02,720
Yeah. Okay.

1756
02:30:02,760 --> 02:30:04,960
Any questions?
I think it's very simple, right?

1757
02:30:04,960 --> 02:30:17,920
Easy peasy.

1758
02:30:17,920 --> 02:30:18,960
Okay.

1759
02:30:20,160 --> 02:30:23,520
So how is everything so far?

1760
02:30:23,520 --> 02:30:25,120
The other than the basics?

1761
02:30:25,120 --> 02:30:29,280
We started from classes and objects.

1762
02:30:29,960 --> 02:30:33,280
Then we started learning new methods.

1763
02:30:33,280 --> 02:30:36,400
If we have two words for changing,
then we have to call this

1764
02:30:36,400 --> 02:30:42,880
method twice.

1765
02:30:42,880 --> 02:30:44,440
Oh, okay. There is one more thing

1766
02:30:45,600 --> 02:30:47,960
and we might see

1767
02:30:52,360 --> 02:30:54,960
and you might see this a lot.

1768
02:30:55,600 --> 02:30:59,360
Now this concept is called
the method of chaining.

1769
02:30:59,360 --> 02:31:14,880
We show you.

1770
02:31:14,880 --> 02:31:18,240
Okay, so let's imagine
we have a string like this.

1771
02:31:18,680 --> 02:31:22,280
A spot is equal to

1772
02:31:29,240 --> 02:31:34,800
something like this.

1773
02:31:34,800 --> 02:31:36,840
What you can do,

1774
02:31:36,880 --> 02:31:39,560
you can call multiple methods

1775
02:31:40,680 --> 02:31:42,840
on the same.

1776
02:31:42,840 --> 02:31:45,480
For example, you can do this

1777
02:31:46,920 --> 02:31:51,720
SDR, not too lowercase,

1778
02:31:52,200 --> 02:31:57,240
not not

1779
02:31:59,400 --> 02:32:01,480
dream, not

1780
02:32:04,320 --> 02:32:07,520
let's say we place

1781
02:32:24,240 --> 02:32:26,800
two. So what I have done here

1782
02:32:27,840 --> 02:32:30,120
I am calling multiple methods.

1783
02:32:30,360 --> 02:32:35,440
It will work just like a pipeline
in a factory or something.

1784
02:32:35,440 --> 02:32:37,800
So what is going to happen

1785
02:32:38,160 --> 02:32:39,800
first?

1786
02:32:40,400 --> 02:32:44,040
All of this, a string is going to

1787
02:32:45,280 --> 02:32:47,520
get converted to lowercase letters

1788
02:32:49,080 --> 02:32:51,880
because we are calling the two lowercase
method.

1789
02:32:52,920 --> 02:32:54,840
Then if there are any

1790
02:32:56,360 --> 02:32:57,960
spaces before and

1791
02:32:57,960 --> 02:33:00,440
after, let me put some spaces intentional.

1792
02:33:01,880 --> 02:33:06,800
Let me put some spaces in the beginning,
at the end of the beginning.

1793
02:33:07,560 --> 02:33:09,760
So then those spaces will be removed

1794
02:33:10,920 --> 02:33:12,400
and then

1795
02:33:12,760 --> 02:33:14,800
whatever string we get as result

1796
02:33:15,840 --> 02:33:19,360
in that string, the great keyword
if president

1797
02:33:20,040 --> 02:33:22,680
will be replaced with good.

1798
02:33:22,920 --> 02:33:24,600
So first

1799
02:33:24,600 --> 02:33:28,200
everything is converted to lowercase

1800
02:33:29,320 --> 02:33:32,360
and then when we will be converting

1801
02:33:32,360 --> 02:33:35,040
everything to lowercase,
obviously great is also

1802
02:33:36,360 --> 02:33:39,120
also going to get converted to lowercase.

1803
02:33:39,120 --> 02:33:39,880
Great.

1804
02:33:40,400 --> 02:33:41,480
And then it will be replaced.

1805
02:33:41,480 --> 02:33:43,280
So if I run this

1806
02:33:45,320 --> 02:33:49,480
we will see that 17 is great.

1807
02:33:49,480 --> 02:33:51,720
What about the spaces between the words?

1808
02:33:51,720 --> 02:33:54,000
No, we are not performing any operation

1809
02:33:54,000 --> 02:33:58,560
to remove or add
or do anything about those spaces yet.

1810
02:33:58,560 --> 02:34:03,040
But if you want to do something, yes,
you can incorporate that as this concept.

1811
02:34:03,040 --> 02:34:04,560
It's called method Chaining.

1812
02:34:04,560 --> 02:34:11,040
One method is being called
on the output of another method.

1813
02:34:11,040 --> 02:34:14,880
You are performing multiple operations
again on the same line.

1814
02:34:15,120 --> 02:34:16,400
Is this clear to everyone?

1815
02:34:17,560 --> 02:34:19,960
You can perform many operations

1816
02:34:19,960 --> 02:34:25,560
if you want on the same line, but

1817
02:34:26,280 --> 02:34:28,680
some of you might still not understand
it fully.

1818
02:34:28,840 --> 02:34:34,680
For example,
if I do this, I will get an editor

1819
02:34:36,120 --> 02:34:38,600
who can explain to me

1820
02:34:38,600 --> 02:34:41,480
why I'm getting a net and why I am unable

1821
02:34:41,480 --> 02:34:43,920
to change new methods in this case

1822
02:34:45,080 --> 02:34:52,080
and this dream just released
all the spaces before and after.

1823
02:34:52,480 --> 02:34:55,480
I exactly look at method

1824
02:34:55,480 --> 02:34:58,480
Chaining is only going work

1825
02:34:58,480 --> 02:35:02,520
if the output of one method is string.

1826
02:35:02,960 --> 02:35:07,720
For example, what output
in which form we get the output.

1827
02:35:07,720 --> 02:35:10,800
When we convert something to lowercase,
do we get a string back?

1828
02:35:12,760 --> 02:35:15,040
Yes. When we print something,

1829
02:35:15,040 --> 02:35:17,640
do we get a string back?

1830
02:35:18,040 --> 02:35:22,760
Yes. Replace all to return
the string here, this first method

1831
02:35:22,760 --> 02:35:27,320
is going to return a string,
but the second one is empty.

1832
02:35:27,320 --> 02:35:28,400
Does it return a string?

1833
02:35:29,800 --> 02:35:32,640
No. It returns the boolean.

1834
02:35:32,640 --> 02:35:35,320
And if a if we have a boolean,

1835
02:35:35,320 --> 02:35:37,600
can we call the replacement
to run a boolean?

1836
02:35:39,360 --> 02:35:42,000
No. So this is not going to work.

1837
02:35:42,000 --> 02:35:45,560
The previous method must return a string

1838
02:35:45,720 --> 02:35:48,840
for the next method to work a format.

1839
02:35:48,840 --> 02:35:51,240
30 is expecting a string.

1840
02:35:51,240 --> 02:35:54,240
It must the previous method
it must return a string.

1841
02:35:54,240 --> 02:35:56,760
Otherwise
this method chaining is not going to work.

1842
02:35:57,160 --> 02:36:01,560
Makes sense.

1843
02:36:01,560 --> 02:36:04,680
Why do we need to trim
or There is no logic, There is no point.

1844
02:36:04,680 --> 02:36:07,440
I'm just trying to show you
that you can call multiple metrics.

1845
02:36:07,720 --> 02:36:09,880
Well, we don't need to trim

1846
02:36:13,440 --> 02:36:17,080
so let me put it

1847
02:36:17,080 --> 02:37:07,000
here.

1848
02:37:07,000 --> 02:37:11,360
Also, one important thing not every class

1849
02:37:11,360 --> 02:37:14,120
sports methods training.

1850
02:37:14,520 --> 02:37:16,600
There is a specific thing that we need

1851
02:37:16,600 --> 02:37:20,280
to implement behind the scenes
for this method training to work.

1852
02:37:20,600 --> 02:37:23,880
So not expect it to work
with all the classes.

1853
02:37:24,520 --> 02:37:27,000
It works with the string because

1854
02:37:27,000 --> 02:37:29,520
it is designed that way. So

1855
02:37:56,400 --> 02:37:58,440
for methods Channing chaining to work

1856
02:38:00,520 --> 02:38:03,200
previous method must

1857
02:38:04,480 --> 02:38:06,000
return

1858
02:38:10,080 --> 02:38:13,560
the expected

1859
02:38:15,040 --> 02:38:18,840
type for the next method.

1860
02:38:19,920 --> 02:38:26,520
For example, for example,

1861
02:38:27,240 --> 02:38:30,280
a replaced method expects

1862
02:38:30,280 --> 02:38:33,360
a string, but is empty.

1863
02:38:33,880 --> 02:38:37,200
Instead of returning a string,
it returns a boolean.

1864
02:38:38,120 --> 02:38:41,520
So here it is going to fail.

1865
02:38:41,520 --> 02:38:42,880
Same matter.

1866
02:38:42,880 --> 02:38:46,320
It expects a string
and that's what lowercase is returning.

1867
02:38:47,040 --> 02:38:49,360
Similarly, replace method

1868
02:38:49,360 --> 02:38:52,800
is expecting a string,
and that's what claim is returning.

1869
02:38:52,800 --> 02:38:56,160
So only when the return type

1870
02:38:56,880 --> 02:39:01,560
of the previous
method matches with the input and whatever

1871
02:39:01,560 --> 02:39:05,880
input that next method is expecting,
then only method training

1872
02:39:05,880 --> 02:39:07,240
is going to work

1873
02:39:08,920 --> 02:39:09,240
slowly.

1874
02:39:09,240 --> 02:39:11,320
Then I will be using it more.

1875
02:39:11,320 --> 02:39:19,320
Things will get better.

1876
02:39:19,320 --> 02:39:20,320
Okay.

1877
02:39:20,440 --> 02:39:25,400
So until here we were actually using
very simple methods.

1878
02:39:25,920 --> 02:39:27,160
Now let's try to use

1879
02:39:28,560 --> 02:39:29,600
a little more on

1880
02:39:29,600 --> 02:39:33,840
more powerful methods
from the string class.

1881
02:39:33,840 --> 02:39:36,280
And one such method is

1882
02:39:57,880 --> 02:40:01,520
let's imagine
you have a number that occurs

1883
02:40:02,640 --> 02:40:07,200
special symbols, things like that, Right?

1884
02:40:08,160 --> 02:40:09,720
Something like this.

1885
02:40:10,720 --> 02:40:13,680
And what you want.

1886
02:40:14,280 --> 02:40:17,920
You want to replace is

1887
02:40:17,920 --> 02:40:20,040
let me put some uppercase letters as one

1888
02:40:22,120 --> 02:40:23,400
you want to replace.

1889
02:40:23,400 --> 02:40:27,560
Let's say all the uppercase
letters are lowercase letters

1890
02:40:27,560 --> 02:40:31,800
or or numbers or special characters.

1891
02:40:31,800 --> 02:40:34,080
So previously

1892
02:40:34,800 --> 02:40:38,280
we were looking for a for an exact match.

1893
02:40:39,560 --> 02:40:41,560
Here we are looking for pattern.

1894
02:40:42,520 --> 02:40:47,320
If this pattern is found anywhere,
if there are, let's say,

1895
02:40:48,080 --> 02:40:51,920
uppercase letters,
I want to replace all of them.

1896
02:40:52,800 --> 02:40:55,720
So here we are
not talking about a specific uppercase

1897
02:40:55,720 --> 02:40:58,200
letter, A, B, C, D, or Z.

1898
02:40:58,200 --> 02:40:59,080
We don't care.

1899
02:40:59,080 --> 02:41:01,680
We just care that the letter is uppercase.

1900
02:41:02,720 --> 02:41:03,360
We want to

1901
02:41:03,360 --> 02:41:07,080
replace all of those uppercase letters
with something.

1902
02:41:07,680 --> 02:41:11,280
So in this kind of situation,
we have another method.

1903
02:41:11,280 --> 02:41:19,160
It's called replace all method,

1904
02:41:19,160 --> 02:41:22,240
replace all.

1905
02:41:22,240 --> 02:41:25,000
And this method is works

1906
02:41:26,040 --> 02:41:30,560
on the regular expression projects.

1907
02:41:30,560 --> 02:41:36,440
The regular expression of value
is a pattern finding language.

1908
02:41:37,200 --> 02:41:41,600
You will learn some domain specific
languages in the future as well.

1909
02:41:42,160 --> 02:41:45,680
For example,
you will learn X spot, which will help you

1910
02:41:45,680 --> 02:41:48,120
identify elements from a web page.

1911
02:41:48,920 --> 02:41:51,520
You will also learn about

1912
02:41:51,520 --> 02:41:55,200
the growing jobs
and again, in domain specific language

1913
02:41:55,560 --> 02:41:59,440
domains, the concept of domain
specific language languages,

1914
02:42:00,000 --> 02:42:03,720
they languages designed
for a very specific task.

1915
02:42:04,200 --> 02:42:07,200
They are not languages
like Java White on C Shop.

1916
02:42:07,720 --> 02:42:10,680
They are designed
for a very specific block.

1917
02:42:10,680 --> 02:42:11,400
For example,

1918
02:42:11,400 --> 02:42:16,040
when you have to search something
from a larger text, when you have to say

1919
02:42:17,000 --> 02:42:18,080
something,

1920
02:42:18,080 --> 02:42:20,600
you have to specify a period of time

1921
02:42:21,960 --> 02:42:24,480
in these kind of scenarios
because these scenarios,

1922
02:42:24,480 --> 02:42:27,720
they can get a little complicated

1923
02:42:27,720 --> 02:42:29,760
exactly for the locators,

1924
02:42:29,760 --> 02:42:32,160
because they can get a little complicated.

1925
02:42:32,760 --> 02:42:36,120
So we have designed a specific languages,

1926
02:42:36,800 --> 02:42:40,240
and I will now take you
the basics of that language.

1927
02:42:40,240 --> 02:42:42,160
You don't need to learn all of it.

1928
02:42:42,160 --> 02:42:44,960
I will share the tools with you
if you want to learn all of it.

1929
02:42:45,360 --> 02:42:49,440
The name is a regular expression
injects or shock

1930
02:42:49,920 --> 02:42:54,560
and it is used to find patterns
from strings.

1931
02:42:55,080 --> 02:42:56,240
Let's do some examples.

1932
02:42:56,240 --> 02:42:57,840
It will make things clear.

1933
02:42:57,840 --> 02:42:59,200
So let's say

1934
02:43:00,000 --> 02:43:02,240
my requirement at this point is

1935
02:43:02,680 --> 02:43:05,440
I want to replace all of the uppercase

1936
02:43:06,600 --> 02:43:08,840
characters letters from the

1937
02:43:10,120 --> 02:43:11,280
So what I can do,

1938
02:43:12,280 --> 02:43:15,120
I can specify a regular expression

1939
02:43:15,480 --> 02:43:18,960
or I can specify a pattern here.

1940
02:43:19,800 --> 02:43:22,520
And for example, the pattern will search

1941
02:43:22,560 --> 02:43:24,720
for all the uppercase letters is

1942
02:43:26,360 --> 02:43:27,800
square brackets.

1943
02:43:27,800 --> 02:43:30,840
Instead, of course, then uppercase,

1944
02:43:30,840 --> 02:43:33,160
a little uppercase. See,

1945
02:43:34,320 --> 02:43:36,840
this is a square bracket

1946
02:43:38,040 --> 02:43:41,160
and this uppercase A dash and Z.

1947
02:43:42,560 --> 02:43:45,000
It is a regular expression,

1948
02:43:45,360 --> 02:43:48,440
which is a saying everywhere.

1949
02:43:49,560 --> 02:43:51,720
If, if anywhere,

1950
02:43:52,440 --> 02:43:54,960
if anywhere in the above string,

1951
02:43:54,960 --> 02:43:57,200
there is any letter present

1952
02:43:58,320 --> 02:44:01,280
from uppercase to uppercase Z.

1953
02:44:01,640 --> 02:44:03,600
Let's find it.

1954
02:44:03,600 --> 02:44:06,080
And after finding it,

1955
02:44:06,080 --> 02:44:08,040
let's say

1956
02:44:10,440 --> 02:44:12,840
replace it with the equal to sign

1957
02:44:12,840 --> 02:44:17,000
or anything you, if you like.

1958
02:44:17,000 --> 02:44:21,440
So what we are saying from
this is string a spot

1959
02:44:22,560 --> 02:44:25,680
wherever uppercase A to Z

1960
02:44:25,680 --> 02:44:28,760
letters are present, replace all of them

1961
02:44:30,000 --> 02:44:30,960
with equal to find.

1962
02:44:30,960 --> 02:44:35,120
So if we run this code,

1963
02:44:35,120 --> 02:44:38,480
look in the output.

1964
02:44:38,480 --> 02:44:42,000
There are two uppercase
letters E, e, and s.

1965
02:44:42,000 --> 02:44:42,600
At the end

1966
02:44:43,560 --> 02:44:45,800
they have
been replaced with equal to sign.

1967
02:44:46,920 --> 02:44:48,600
There were uppercase letters.

1968
02:44:48,600 --> 02:44:50,640
Is there s x?

1969
02:44:51,680 --> 02:44:53,280
They have also been replaced.

1970
02:44:53,280 --> 02:44:55,200
We need to find

1971
02:44:55,760 --> 02:44:58,560
actually this regular expression.

1972
02:44:59,160 --> 02:45:02,280
It's it is a link to your ASCII table.

1973
02:45:02,280 --> 02:45:03,400
Do you remember that?

1974
02:45:03,400 --> 02:45:06,000
I show you the ASCII table

1975
02:45:07,480 --> 02:45:09,120
of the perfect.

1976
02:45:09,120 --> 02:45:10,360
Let me show you more examples.

1977
02:45:10,360 --> 02:45:13,560
Then I will show you how it is
linked to that.

1978
02:45:13,960 --> 02:45:15,360
Ask a table.

1979
02:45:15,720 --> 02:45:17,440
What do think? Try to guess.

1980
02:45:17,440 --> 02:45:20,280
Try to guess If I say

1981
02:45:20,280 --> 02:45:22,200
A to C,

1982
02:45:22,800 --> 02:45:26,400
do you think this is z or x or S?

1983
02:45:26,400 --> 02:45:30,360
They will be replaced this time.

1984
02:45:30,360 --> 02:45:33,480
You know, only uppercase letters

1985
02:45:34,160 --> 02:45:36,600
from A to C will be replaced

1986
02:45:36,600 --> 02:45:40,280
with equal sign.

1987
02:45:40,280 --> 02:45:42,960
So look, S is still there.

1988
02:45:42,960 --> 02:45:44,120
That is still there.

1989
02:45:44,120 --> 02:45:48,360
As is true, their access to their.

1990
02:45:48,360 --> 02:45:50,920
So if you remember the ASCII table,
basically

1991
02:45:50,920 --> 02:45:52,800
it is working based on that ASCII.

1992
02:45:52,800 --> 02:45:57,360
David Let me show you more examples
and then I will show you.

1993
02:45:57,360 --> 02:45:59,960
Let's say, for example, this time
the requirement is

1994
02:46:00,480 --> 02:46:03,960
you want to replace
all of the lowercase letters.

1995
02:46:04,400 --> 02:46:05,640
Very simple.

1996
02:46:05,640 --> 02:46:07,240
And this can you

1997
02:46:07,240 --> 02:46:10,920
if I want to replace all of the lowercase
letters, how can I specify that

1998
02:46:12,600 --> 02:46:13,560
exactly?

1999
02:46:13,560 --> 02:46:16,440
You can specify a lowercase e

2000
02:46:17,560 --> 02:46:19,200
galaxy,

2001
02:46:19,680 --> 02:46:23,040
and this time no uppercase
letter will be attached.

2002
02:46:23,240 --> 02:46:25,480
Only the lowercase letters
will be replaced

2003
02:46:28,920 --> 02:46:30,720
by look here

2004
02:46:31,040 --> 02:46:34,560
key SD and they were replaced.

2005
02:46:34,560 --> 02:46:37,560
But is the X

2006
02:46:38,040 --> 02:46:41,400
all of the uppercase?

2007
02:46:41,400 --> 02:46:43,600
This method is called replace all here.

2008
02:46:43,680 --> 02:46:45,320
This is the name of the method.

2009
02:46:45,320 --> 02:46:48,600
Replace
all the technique that we are using here.

2010
02:46:48,600 --> 02:47:02,160
It's called regular expression.

2011
02:47:02,160 --> 02:47:08,280
Are things making sense?

2012
02:47:08,280 --> 02:47:10,520
If they're too minor,
say exactly the same thing.

2013
02:47:11,880 --> 02:47:13,440
Oh, yes. Let me show you other examples.

2014
02:47:13,440 --> 02:47:16,080
So let's say, for example,

2015
02:47:17,040 --> 02:47:19,320
I can specify a number as well.

2016
02:47:19,320 --> 02:47:22,240
I can say 029.

2017
02:47:22,920 --> 02:47:25,080
Can you combine two? Yes,
we can combine. Two.

2018
02:47:25,080 --> 02:47:28,360
Just give me the let me go
step by step What we can we can do that.

2019
02:47:29,880 --> 02:47:30,600
What do you think?

2020
02:47:30,600 --> 02:47:32,080
What will happen now?

2021
02:47:32,080 --> 02:47:43,000
I'm saying 0 to 9,

2022
02:47:43,000 --> 02:47:46,800
all the digits from 0 to 9

2023
02:47:47,320 --> 02:47:52,520
will be replaced with equal time.

2024
02:47:52,520 --> 02:47:57,360
So the uppercase letters
are there, lowercase letters?

2025
02:47:57,360 --> 02:48:01,080
Are there special Are there only numbers?

2026
02:48:01,080 --> 02:48:03,480
Only digits from 0 to 9 are replaced.

2027
02:48:03,960 --> 02:48:05,760
And one more thing. What do you think?

2028
02:48:05,760 --> 02:48:09,040
What will happen
if I if I replace it with empty string

2029
02:48:10,720 --> 02:48:11,640
in the replacement?

2030
02:48:11,640 --> 02:48:20,560
If I don't specify anything,
I simply specify double course.

2031
02:48:20,560 --> 02:48:23,040
They will be basically removed.

2032
02:48:23,040 --> 02:48:24,800
They will be removed.

2033
02:48:25,040 --> 02:48:28,560
They will be removed
so they can show you. You

2034
02:48:29,560 --> 02:48:30,520
look, now

2035
02:48:30,520 --> 02:48:33,600
we have a shorter string
so you can basically use it

2036
02:48:33,600 --> 02:48:36,640
to remove things
as well as replace or remove.

2037
02:48:37,560 --> 02:48:39,720
You can find any pattern

2038
02:48:39,720 --> 02:48:44,040
just try to get a sense of
of how these ranges are working.

2039
02:48:44,760 --> 02:48:56,480
Is it clear
or is there anyone who is confused?

2040
02:48:56,480 --> 02:49:01,440
Yes, there is a range for the characters
as well.

2041
02:49:01,440 --> 02:49:02,040
Okay.

2042
02:49:02,040 --> 02:49:04,880
Now let me pull the ASCII table

2043
02:49:04,920 --> 02:49:17,400
for you.

2044
02:49:17,400 --> 02:49:23,800
Yes, it can work with spaces as well.

2045
02:49:23,800 --> 02:49:27,840
For example,
if there are spaces in between

2046
02:49:28,800 --> 02:49:30,960
like this.

2047
02:49:30,960 --> 02:49:34,280
So to specify the space,
there are multiple ways

2048
02:49:37,760 --> 02:49:40,560
you can put a space like this

2049
02:49:40,560 --> 02:49:41,560
empty one.

2050
02:49:41,880 --> 02:49:44,880
And so it will try to search
for all the spaces

2051
02:49:44,880 --> 02:49:49,400
and then it will remove.

2052
02:49:49,400 --> 02:49:55,800
So look, there is no space in the output,
so it will basically remove,

2053
02:49:55,800 --> 02:50:01,800
even if there are spaces everywhere,
everywhere like this, like this, anywhere.

2054
02:50:01,800 --> 02:50:09,960
If a space is found, it will be removed.

2055
02:50:09,960 --> 02:50:23,400
We are put with our spaces.

2056
02:50:23,400 --> 02:50:26,040
How to keep one space
between all the words.

2057
02:50:26,040 --> 02:50:27,920
Alex Flexible step by step.

2058
02:50:27,920 --> 02:50:33,360
Next step I will teach you
everything that is possible.

2059
02:50:33,360 --> 02:50:36,000
Looking right.

2060
02:50:36,000 --> 02:50:39,320
Basically, this regular expression
is working based on this table.

2061
02:50:39,960 --> 02:50:41,600
For example,

2062
02:50:42,320 --> 02:50:45,040
the you see the number

2063
02:50:45,680 --> 02:50:49,400
for the upper PSA is 65.

2064
02:50:51,000 --> 02:50:53,240
And if I specify

2065
02:50:56,120 --> 02:50:59,360
uppercase A to lowercase

2066
02:50:59,360 --> 02:51:03,080
Z, everything that comes in between

2067
02:51:03,280 --> 02:51:08,600
all of the symbols, uppercase,
lowercase, they will all be replaced.

2068
02:51:09,880 --> 02:51:12,200
Uppercase E

2069
02:51:12,200 --> 02:51:15,240
as the number 65, the representation

2070
02:51:16,360 --> 02:51:17,960
then increasing one by one.

2071
02:51:17,960 --> 02:51:22,680
B is 66, C 67, and then lowercase

2072
02:51:22,680 --> 02:51:27,120
A is 97, lowercase B is 98, lowercase
Z is.

2073
02:51:27,520 --> 02:51:30,720
So basically everything that comes
in this range,

2074
02:51:30,720 --> 02:51:33,440
65 to

2075
02:51:33,840 --> 02:51:37,080
Z is 122

2076
02:51:37,320 --> 02:51:41,080
inside of the ask a table
if I am specifying my regular expression

2077
02:51:41,080 --> 02:51:44,960
like this, a dash lowercase

2078
02:51:44,960 --> 02:51:49,440
z, this is how computer will interpret

2079
02:51:49,440 --> 02:51:53,640
this computer will go and find
the representation for the upper PC,

2080
02:51:54,840 --> 02:51:56,680
which is 65.

2081
02:51:56,680 --> 02:51:59,720
Then It will go to the A table
and find the representation

2082
02:51:59,720 --> 02:52:02,880
for lowercase z, which is 122.

2083
02:52:03,240 --> 02:52:05,640
Everything that comes in between.

2084
02:52:06,600 --> 02:52:08,640
Now it will consider all of those things.

2085
02:52:09,160 --> 02:52:15,040
For example,

2086
02:52:15,040 --> 02:52:18,120
for example, if I say

2087
02:52:19,000 --> 02:52:24,000
uppercase, it will lowercase z.

2088
02:52:24,000 --> 02:52:27,840
Not only all the uppercase
letters will be replaced removed

2089
02:52:28,080 --> 02:52:32,120
because we are using up the string,
all the lowercase letters will be removed

2090
02:52:32,800 --> 02:52:37,680
and these symbols like bracket

2091
02:52:38,600 --> 02:52:43,240
buried symbol, they will also be replaced
because they are within the range

2092
02:52:50,000 --> 02:52:50,960
to look

2093
02:52:54,800 --> 02:52:58,440
all of these things.

2094
02:52:58,440 --> 02:53:00,640
They were in the range.

2095
02:53:00,680 --> 02:53:04,880
This was also invented
two, three, two was not in the range,

2096
02:53:04,880 --> 02:53:09,840
space was not there, nine eight was not
there nor symbol was not there.

2097
02:53:09,840 --> 02:53:14,360
But look at this
great symbol, the scattered symbol.

2098
02:53:15,360 --> 02:53:17,120
Is it in the range?

2099
02:53:17,320 --> 02:53:21,960
Let's see from the ask the table,

2100
02:53:21,960 --> 02:53:25,800
the scattered symbol.

2101
02:53:25,800 --> 02:53:26,840
Look, there

2102
02:53:27,800 --> 02:53:29,600
it is within the range.

2103
02:53:29,600 --> 02:53:32,440
So basically everything that you put

2104
02:53:34,720 --> 02:53:38,280
will go and match that thing
from the ASCII table

2105
02:53:38,920 --> 02:53:42,560
and from that range, the range
that could get from the ask the table,

2106
02:53:42,920 --> 02:53:45,560
whatever comes between

2107
02:53:45,560 --> 02:53:48,360
all of those combinations,

2108
02:53:48,360 --> 02:53:51,480
all of those letters, director symbols,
everything will be considered.

2109
02:53:52,800 --> 02:53:56,640
For example,

2110
02:53:56,640 --> 02:54:01,760
let's say if you specify the end
symbol as the starting point

2111
02:54:02,880 --> 02:54:06,000
and you specify, let's say the semicolon

2112
02:54:08,080 --> 02:54:11,640
as the ending point,
do you think everything that we see in

2113
02:54:11,640 --> 02:54:17,320
between will be replaced?

2114
02:54:17,320 --> 02:54:20,160
So let's try this.

2115
02:54:20,280 --> 02:54:21,720
Oh, by the way,

2116
02:54:22,560 --> 02:54:25,520
there are some special characters
which have a special meaning.

2117
02:54:26,520 --> 02:54:28,520
So let me specify the

2118
02:54:29,320 --> 02:54:34,800
and and semicolon.

2119
02:54:34,800 --> 02:54:40,440
So there are some special characters
which has a special meaning.

2120
02:54:40,440 --> 02:54:43,200
So anything that comes in the range

2121
02:54:46,320 --> 02:54:49,640
will be replaced.

2122
02:54:49,640 --> 02:54:56,200
Look here,
all the numbers are in this range.

2123
02:54:57,240 --> 02:55:00,000
Zero one, two, three, four, five.

2124
02:55:00,000 --> 02:55:02,840
Colon forward slash plus sign

2125
02:55:02,840 --> 02:55:05,360
minus sign star, curly brackets.

2126
02:55:06,800 --> 02:55:10,320
You can put all of them.

2127
02:55:10,320 --> 02:55:12,680
For example, look at these.

2128
02:55:13,640 --> 02:55:14,600
Look at this.

2129
02:55:14,600 --> 02:55:16,520
Look at this table.

2130
02:55:16,800 --> 02:55:20,880
I am specifying the range
starting from the symbol and semicolon

2131
02:55:21,720 --> 02:55:25,880
and these opening and closing brackets,
they are within the range.

2132
02:55:26,160 --> 02:55:28,880
They think they will be replaced.

2133
02:55:28,880 --> 02:55:41,680
These one that I have just
inserted, they are all gone.

2134
02:55:43,240 --> 02:55:45,680
So basically it's the ASCII table.

2135
02:55:46,920 --> 02:55:50,400
These ranges,
these things that we are specifying here.

2136
02:55:51,080 --> 02:55:54,120
Basically Java is going back to the table

2137
02:55:54,800 --> 02:56:00,000
and from that ASCII table, it is trying
to figure out what it should consider

2138
02:56:00,280 --> 02:56:03,960
and which comes what comes in the range

2139
02:56:04,400 --> 02:56:08,000
and what is not within the range.

2140
02:56:08,000 --> 02:56:12,160
Making sense.

2141
02:56:12,160 --> 02:56:14,760
For example,
let me show you more examples.

2142
02:56:14,760 --> 02:56:16,920
Let me say control C control. We

2143
02:56:24,040 --> 02:56:25,520
is it time for break?

2144
02:56:25,520 --> 02:56:27,640
Okay, We can have a break.

2145
02:56:27,640 --> 02:56:47,880
And then after the break,
we will continue from here.

2146
02:56:47,880 --> 02:56:51,520
So place things and basically

2147
02:56:51,520 --> 02:56:55,000
patrons say

2148
02:56:57,840 --> 02:57:00,160
this is how we specify
the regular expressions.

2149
02:57:00,160 --> 02:57:03,400
Okay, now

2150
02:57:05,200 --> 02:57:06,280
this is good.

2151
02:57:07,200 --> 02:57:09,720
Based on the ask a table,
you can pick any range,

2152
02:57:10,440 --> 02:57:13,160
you can specify that range
and then it's going to work.

2153
02:57:13,160 --> 02:57:18,280
But what happens?

2154
02:57:18,280 --> 02:57:20,680
Things are not that
straightforward. For example,

2155
02:57:21,720 --> 02:57:23,880
sometimes

2156
02:57:24,080 --> 02:57:25,400
maybe

2157
02:57:25,800 --> 02:57:30,480
you are interested in only replacing
uppercase letters and numbers

2158
02:57:30,600 --> 02:57:36,360
so and single and how you can do that,

2159
02:57:36,360 --> 02:57:40,520
you can basically specify multiple ranges.

2160
02:57:40,520 --> 02:57:43,800
For example,
you can say, I only want to remove

2161
02:57:44,080 --> 02:57:48,360
or replace uppercase letters
and only the numbers.

2162
02:57:48,360 --> 02:57:51,280
So there is no symbol
and symbol in between.

2163
02:57:52,160 --> 02:57:53,400
There is no nothing.

2164
02:57:53,400 --> 02:57:56,320
You just specify two ranges
just like this.

2165
02:57:57,240 --> 02:58:00,120
And now what
we are saying in this range is

2166
02:58:01,440 --> 02:58:06,000
replace or remove
all of the uppercase letters.

2167
02:58:06,000 --> 02:58:08,560
Replace or remove

2168
02:58:09,400 --> 02:58:12,960
all the numbers from 0 to 9.

2169
02:58:13,840 --> 02:58:17,400
So for example, now we run this code

2170
02:58:20,280 --> 02:58:22,000
so you can see from this

2171
02:58:22,000 --> 02:58:24,840
string all the uppercase letters

2172
02:58:25,800 --> 02:58:30,480
from A to Z, all the numbers
from zero nine, they have been removed

2173
02:58:30,720 --> 02:58:36,000
because our replacement is empty string
and special symbols are there.

2174
02:58:36,000 --> 02:58:38,480
Spaces are different.
Lowercase letters can be.

2175
02:58:38,480 --> 02:58:43,080
So basically this is how you can specify
multiple ranges.

2176
02:58:44,000 --> 02:58:48,320
And then let's say,
I don't know, maybe you want to say

2177
02:58:51,600 --> 02:58:55,520
0 to 5 numbers and then you

2178
02:58:55,520 --> 02:59:01,720
don't like to replace the number from,
the number six and seven.

2179
02:59:01,720 --> 02:59:05,040
Then you can specify another range
like this,

2180
02:59:06,080 --> 02:59:08,120
and then maybe you want to replace
something

2181
02:59:08,320 --> 02:59:12,720
this a two letter J
So any range, basically

2182
02:59:12,800 --> 02:59:15,440
multiple ranges, whatever you like.

2183
02:59:15,680 --> 02:59:16,920
Are things making sense?

2184
02:59:16,920 --> 02:59:25,480
What I, what am I doing here.

2185
02:59:25,480 --> 02:59:30,360
So now include on it.

2186
02:59:30,360 --> 02:59:34,680
Look, all the uppercase letters are gone.

2187
02:59:35,920 --> 02:59:38,960
Then numbers from 0 to 5 are gone.

2188
02:59:39,040 --> 02:59:43,960
Let me put the number six here.

2189
02:59:43,960 --> 02:59:45,400
So it reads one character.

2190
02:59:45,400 --> 02:59:47,320
The character by character?

2191
02:59:47,320 --> 02:59:48,760
Yes, correct them.

2192
02:59:48,760 --> 02:59:50,960
So tell me, why is this number six?

2193
02:59:50,960 --> 03:00:00,960
Will it be removed?

2194
03:00:00,960 --> 03:00:02,040
Exactly.

2195
03:00:02,040 --> 03:00:08,840
So we see the number of six, and I am
specifying lowercase letters from eight to

2196
03:00:10,320 --> 03:00:13,920
which means which means

2197
03:00:14,560 --> 03:00:15,240
this letter

2198
03:00:15,240 --> 03:00:18,560
s lowercase s, Will it be replaced

2199
03:00:19,680 --> 03:00:20,880
or removed?

2200
03:00:21,040 --> 03:00:25,080
No, because it does not fall in anything.

2201
03:00:25,080 --> 03:00:29,880
So someone was asking me, how can we use
the end operator, specify multiple things.

2202
03:00:29,880 --> 03:00:35,040
So this is how you can do it.

2203
03:00:35,040 --> 03:00:38,480
There is one more variation
that you might want to try.

2204
03:00:39,120 --> 03:00:41,920
For example, you can specify

2205
03:00:41,920 --> 03:00:43,960
individual as well.

2206
03:00:43,960 --> 03:00:44,800
Individual letters.

2207
03:00:44,800 --> 03:00:47,680
For example,
you want to only replace lowercase k

2208
03:00:48,320 --> 03:00:50,760
lowercase as

2209
03:00:50,760 --> 03:00:53,160
the digit to

2210
03:00:53,160 --> 03:00:54,480
the uppercase s.

2211
03:00:54,480 --> 03:00:55,800
That's also possible.

2212
03:00:55,800 --> 03:00:58,480
You can specify individual characters,

2213
03:00:59,280 --> 03:01:03,760
so wherever
it will see the lowercase lowercase s two,

2214
03:01:03,760 --> 03:01:07,040
unless it will replace that
and everything else,

2215
03:01:08,040 --> 03:01:12,480
it will be it will be it will be there.

2216
03:01:12,480 --> 03:01:13,440
So look,

2217
03:01:14,040 --> 03:01:18,480
only the K from the beginning,
it has been removed.

2218
03:01:19,800 --> 03:01:22,280
Then the lowercase s removed,

2219
03:01:23,280 --> 03:01:27,000
then the radius tool was removed
and the upper class

2220
03:01:27,600 --> 03:01:35,760
was Mr..

2221
03:01:35,760 --> 03:01:40,800
Okay, so everything looks good in here.

2222
03:01:40,800 --> 03:01:45,920
Now I will show you
some advanced techniques.

2223
03:01:45,920 --> 03:01:48,920
Can you please quickly
expand from first line, please?

2224
03:01:49,520 --> 03:01:52,160
No, obviously I will not be explaining
from the first line

2225
03:01:52,200 --> 03:01:56,520
why you want me to repeat what I have done
in the last 20 minutes.

2226
03:01:56,520 --> 03:01:58,360
You will not hear

2227
03:02:05,160 --> 03:02:05,920
what's wrong

2228
03:02:05,920 --> 03:02:11,400
If relics and replacement comes out,
it means either you did not specify

2229
03:02:11,400 --> 03:02:14,760
the regular expression properly
or you are not following the syntax rule.

2230
03:02:15,240 --> 03:02:16,680
Share shared a screenshot.

2231
03:02:16,680 --> 03:02:19,280
I will tell you what you are doing wrong.

2232
03:02:19,280 --> 03:02:20,920
How to replace dashes.

2233
03:02:20,920 --> 03:02:24,480
You can specify a dash like this

2234
03:02:24,480 --> 03:02:30,600
individual dash.

2235
03:02:30,600 --> 03:02:32,560
I think it should
work. We're not sure that

2236
03:02:33,800 --> 03:02:36,000
this school

2237
03:02:36,720 --> 03:02:37,680
like this.

2238
03:02:38,400 --> 03:02:40,080
I understand your point you.

2239
03:02:40,080 --> 03:02:45,400
But some some characters
are part of the syntax.

2240
03:02:46,040 --> 03:02:48,960
So how replace them
you can specify them separately.

2241
03:02:48,960 --> 03:02:57,840
No, this.

2242
03:02:57,840 --> 03:03:00,520
If you want to remove dash,

2243
03:03:00,520 --> 03:03:02,720
you can specify a dash like this.

2244
03:03:02,720 --> 03:03:12,680
But this is what I have done.

2245
03:03:12,680 --> 03:03:17,760
Any other question base anything
which is not cleared, any line number.

2246
03:03:18,280 --> 03:03:23,400
So in order to remove dash or use it
at the end of it, know it can be anywhere.

2247
03:03:23,840 --> 03:03:27,720
You will do it at the end
or before it can be anywhere like this.

2248
03:03:28,120 --> 03:03:31,800
But if you put it between two letters,
then it will take it

2249
03:03:31,800 --> 03:03:37,520
as a range.

2250
03:03:37,520 --> 03:03:42,000
Uppercase
class will not be removed by A to Z

2251
03:03:55,840 --> 03:03:57,280
making comment

2252
03:03:57,280 --> 03:04:07,840
out of the other course
and only execute that line.

2253
03:04:07,840 --> 03:04:12,000
What is the usage of this written code
in real life?

2254
03:04:12,000 --> 03:04:17,520
Okay, so have you seen when you try to create a username and password on a website,

2255
03:04:18,520 --> 03:04:20,760
they can go through your password

2256
03:04:20,760 --> 03:04:25,080
and they tell you
that your password is not strong enough.

2257
03:04:25,080 --> 03:04:28,960
If should contain a special character,
it should contain uppercase

2258
03:04:28,960 --> 03:04:32,400
letters, lowercase letters, numbers
What do you think?

2259
03:04:32,400 --> 03:04:35,720
How they are identified,
how they are looking at these patterns,

2260
03:04:36,160 --> 03:04:39,480
how they are figuring it out,
whether you are using a lowercase

2261
03:04:39,480 --> 03:04:44,080
uppercase
special, deducing a password or not.

2262
03:04:44,800 --> 03:04:48,000
The they use behind the scenes,
these regular expressions.

2263
03:04:48,600 --> 03:04:52,960
They also use these regular expressions.

2264
03:04:52,960 --> 03:04:55,080
Make sure you are entering a proper email.

2265
03:04:55,600 --> 03:04:56,280
For example,

2266
03:04:56,280 --> 03:05:01,080
you can easily find regular expressions
on the internet for these common things.

2267
03:05:01,080 --> 03:05:04,800
For example, it's a very common thing
that whenever you enter an email

2268
03:05:04,920 --> 03:05:08,560
on any website, for example,
if I go to Facebook

2269
03:05:11,080 --> 03:05:12,880
and if I say out of the eight

2270
03:05:13,920 --> 03:05:15,920
something like this

2271
03:05:19,800 --> 03:05:22,400
or let me try to

2272
03:05:22,400 --> 03:05:24,800
create a new account

2273
03:05:24,800 --> 03:05:33,560
to create a new account,
this is not a proper

2274
03:05:33,720 --> 03:05:38,920
email, right?

2275
03:05:38,920 --> 03:05:41,000
Well, what do you think?

2276
03:05:41,360 --> 03:05:45,760
How it is figuring it out
if it is a email or not,

2277
03:05:45,760 --> 03:05:49,200
it is looking for the advertising world
and it is looking for that.

2278
03:05:49,200 --> 03:05:53,040
You have a dot com or dot AEI
or something like that that at the end

2279
03:05:53,360 --> 03:05:54,640
and all of these things,

2280
03:05:54,640 --> 03:05:57,840
all of this is possible
with the help of regular expression.

2281
03:05:57,840 --> 03:06:03,360
For example, a regular expression

2282
03:06:05,680 --> 03:06:10,080
to verify email
and you don't have to write it all

2283
03:06:10,640 --> 03:06:12,920
and you can easily

2284
03:06:14,520 --> 03:06:17,280
find already written regular expressions

2285
03:06:18,680 --> 03:06:20,960
which will validate, look,

2286
03:06:21,520 --> 03:06:25,920
this is basically a regular expression,
a very complex one. Yes.

2287
03:06:25,920 --> 03:06:28,960
And I don't think it's going to make
a lot of sense at this point.

2288
03:06:29,960 --> 03:06:30,800
But if

2289
03:06:30,800 --> 03:06:34,560
the regular expression,
it will check your email,

2290
03:06:34,560 --> 03:06:38,680
whether it is from Google, Amazon, dot
com dot org,

2291
03:06:39,240 --> 03:06:45,240
any domain, anything, it will make sure
that you are using a proper email.

2292
03:06:45,240 --> 03:06:49,320
You can also validate numbers,
for example, in a lot of forms

2293
03:06:49,320 --> 03:06:51,320
when you enter your

2294
03:06:52,120 --> 03:06:55,040
when you enter your information,
they can quickly tell you

2295
03:06:55,040 --> 03:06:58,080
whether you are using your proper
mobile number or not.

2296
03:06:58,520 --> 03:07:02,000
What do you think about
how do they do that?

2297
03:07:02,000 --> 03:07:04,240
For example, if you are entering seven

2298
03:07:05,320 --> 03:07:08,200
five digit phone number,

2299
03:07:08,200 --> 03:07:10,000
something like this,

2300
03:07:10,160 --> 03:07:11,640
please enter a valid number.

2301
03:07:11,640 --> 03:07:13,680
They are using regular expressions.

2302
03:07:14,200 --> 03:07:17,160
So basically it is a very powerful thing

2303
03:07:17,160 --> 03:07:22,120
to make sure that the user is entering
proper data.

2304
03:07:22,120 --> 03:07:24,000
You create a regular expression

2305
03:07:24,000 --> 03:07:28,280
which will verify everything from the data
that user is entering

2306
03:07:28,840 --> 03:07:32,240
and it's heavily
used in these applications

2307
03:07:32,240 --> 03:07:36,200
where you create new user ID,
you enter your password

2308
03:07:36,200 --> 03:07:41,880
filling out these forms,
everything that you see on the Internet.

2309
03:07:41,880 --> 03:07:50,080
Is it clear
now how they are used in real life?

2310
03:07:50,080 --> 03:07:53,920
Now, some of you might want to go
into the details

2311
03:07:53,920 --> 03:07:57,240
and might want to learn more
about regular expressions.

2312
03:07:57,720 --> 03:08:00,680
I actually don't recommend it,
but some of you

2313
03:08:01,480 --> 03:08:04,000
it's good if you have time.

2314
03:08:04,000 --> 03:08:05,840
There is a website which is called

2315
03:08:07,080 --> 03:08:13,320
Radix, so

2316
03:08:14,320 --> 03:08:18,440
it has all the explanations
how these regular expressions work.

2317
03:08:18,440 --> 03:08:28,040
For example, sorry about it.

2318
03:08:28,040 --> 03:08:31,360
For example,
if you look at the queue sheet

2319
03:08:31,360 --> 03:08:33,480
when you write

2320
03:08:33,480 --> 03:08:36,120
slash and W, it means

2321
03:08:37,280 --> 03:08:40,160
any word.

2322
03:08:40,760 --> 03:08:44,400
When you write backward slash D
it means a digit.

2323
03:08:45,600 --> 03:08:50,400
For example here,

2324
03:08:50,400 --> 03:08:52,320
if I write

2325
03:08:57,640 --> 03:09:00,840
this digit here,

2326
03:09:00,840 --> 03:09:07,840
the community will be square brackets.

2327
03:09:07,840 --> 03:09:10,960
It means any digit.

2328
03:09:10,960 --> 03:09:14,760
Let's run it.

2329
03:09:14,760 --> 03:09:17,080
So look at this output,

2330
03:09:17,880 --> 03:09:22,600
all the digits
which were present in this string.

2331
03:09:22,600 --> 03:09:24,440
They are all gone.

2332
03:09:24,440 --> 03:09:26,400
This backward.

2333
03:09:26,400 --> 03:09:29,160
Backward slash D means any digit

2334
03:09:29,680 --> 03:09:33,240
backward slash w means any word.

2335
03:09:33,960 --> 03:09:36,600
Backward slash S means space.

2336
03:09:36,960 --> 03:09:38,480
For example,

2337
03:09:39,080 --> 03:09:41,320
there are a lot of spaces as well

2338
03:09:41,320 --> 03:09:45,800
in our string,
so one way you can directly put the space.

2339
03:09:45,800 --> 03:09:49,560
However, one other way is
you can put backward slash s

2340
03:09:49,920 --> 03:09:55,440
and we need an extra one
so that it does not take it as literal.

2341
03:09:56,400 --> 03:10:01,800
So this backward slash backward slash
s means a space so all the spaces will go.

2342
03:10:01,800 --> 03:10:02,560
Now look,

2343
03:10:04,080 --> 03:10:04,760
so these

2344
03:10:04,760 --> 03:10:08,640
are all the
syntax of this domain specific language

2345
03:10:08,640 --> 03:10:11,920
which is called red x regular expression.

2346
03:10:13,560 --> 03:10:18,600
So and if you want to learn it,
you can basically use this website.

2347
03:10:18,600 --> 03:10:23,080
For example,
you can write a regular expression here.

2348
03:10:23,840 --> 03:10:27,120
So if you write D

2349
03:10:27,680 --> 03:10:29,880
and let's put some numbers here

2350
03:10:30,960 --> 03:10:31,560
then,

2351
03:10:32,440 --> 03:10:37,200
so you see it is highlighting
all the numbers from.

2352
03:10:37,200 --> 03:10:40,360
This complete text here,

2353
03:10:40,360 --> 03:10:44,480
if I tried backwards slash w look,

2354
03:10:44,480 --> 03:10:47,360
it is identifying all the words

2355
03:10:48,480 --> 03:10:51,120
from this next paragraph.

2356
03:10:51,120 --> 03:10:54,720
So if I specify a square brackets, a, b, c

2357
03:10:54,720 --> 03:10:57,840
it means any of e, B

2358
03:10:57,840 --> 03:11:00,760
or C, wherever
it will see those it will highlight.

2359
03:11:01,400 --> 03:11:05,520
So if I write square brackets A, B, C,

2360
03:11:06,280 --> 03:11:09,640
it will highlight all everywhere,
wherever it will see

2361
03:11:09,640 --> 03:11:12,600
the letter E or B or S.

2362
03:11:13,320 --> 03:11:16,720
When you put a range here A to Z, it

2363
03:11:16,720 --> 03:11:20,120
will highlight
any uppercase letters from A to Z.

2364
03:11:21,280 --> 03:11:22,560
So you can basically

2365
03:11:22,560 --> 03:11:26,560
learn a test
and all the explanation and code.

2366
03:11:26,600 --> 03:11:29,920
Everything is given to those
who want to dig a little deeper,

2367
03:11:30,120 --> 03:11:31,280
more to understand better.

2368
03:11:31,280 --> 03:11:35,640
You guys can use this website

2369
03:11:36,040 --> 03:11:45,600
and we shared the link with you.

2370
03:11:45,600 --> 03:11:48,040
So again,

2371
03:11:49,440 --> 03:11:54,040
there is one more thing
that I want to show you.

2372
03:11:54,040 --> 03:11:58,360
Are you remember the not symbol,
not basically takes

2373
03:11:58,360 --> 03:12:01,920
the note of whatever logic you put

2374
03:12:03,080 --> 03:12:06,120
that not also works here,
but symbol is little different.

2375
03:12:06,120 --> 03:12:07,680
For example,

2376
03:12:08,640 --> 03:12:11,360
if you specify A to Z

2377
03:12:12,400 --> 03:12:15,600
and, if you put the scarab symbol
before like this,

2378
03:12:17,200 --> 03:12:20,920
it means remove everything,

2379
03:12:21,760 --> 03:12:25,920
but not uppercase A to Z.

2380
03:12:26,800 --> 03:12:28,000
Edit this.

2381
03:12:28,000 --> 03:12:31,240
Let me repeat remove everything

2382
03:12:31,880 --> 03:12:34,800
but not uppercase A to Z.

2383
03:12:35,240 --> 03:12:39,240
So if you do that,

2384
03:12:39,240 --> 03:12:42,840
only the uppercase letters are left.

2385
03:12:43,800 --> 03:12:50,000
Everything else has been removed.

2386
03:12:50,000 --> 03:12:54,760
And for example,
if you do this, for example,

2387
03:12:54,760 --> 03:12:58,520
if you say do not remove A to Z, also
do not

2388
03:12:58,600 --> 03:13:03,200
do not remove edge will be
and also do not remove the numbers.

2389
03:13:03,200 --> 03:13:05,680
What do you think?
What will be replaced this time?

2390
03:13:05,680 --> 03:13:09,720
I'm saying do not remove
letters, lowercase letters and numbers.

2391
03:13:09,720 --> 03:13:18,640
What will be left?

2392
03:13:18,640 --> 03:13:21,360
All the special characters

2393
03:13:22,440 --> 03:13:24,360
will be removed.

2394
03:13:24,480 --> 03:13:27,120
And other than that

2395
03:13:27,520 --> 03:13:29,560
all the uppercase letters, lowercase
letters

2396
03:13:29,560 --> 03:13:32,640
and numbers will be retained.

2397
03:13:32,640 --> 03:13:35,560
So look, this is how you clean your input.

2398
03:13:35,960 --> 03:13:39,840
A lot of the time you will be processing
the data from text based files.

2399
03:13:40,560 --> 03:13:44,640
And before you process the data, lot
of the time you want to clean that data

2400
03:13:44,720 --> 03:13:49,520
you want to remove
maybe by injection logs, the spaces

2401
03:13:49,520 --> 03:13:54,920
and or special characters
and anything you can process.

2402
03:13:54,920 --> 03:13:55,760
You are staying in

2403
03:13:55,760 --> 03:13:59,280
whichever way you want with
the help of these required expressions.

2404
03:14:00,080 --> 03:14:03,360
So I am saying do not remove uppercase
A to Z,

2405
03:14:04,320 --> 03:14:06,640
do not remove or to be

2406
03:14:08,000 --> 03:14:13,120
segment policy and do not remove 0 to 9.

2407
03:14:13,120 --> 03:14:18,560
And other than this, whatever is present
in my string and remove all of that.

2408
03:14:19,200 --> 03:14:23,040
So you see this
how this not a symbol is helping you here

2409
03:14:23,400 --> 03:14:27,120
not symbol says do not remove these things

2410
03:14:28,120 --> 03:14:29,080
but everything

2411
03:14:29,080 --> 03:14:34,440
other than this.

2412
03:14:34,440 --> 03:14:37,480
So I see lowercase uppercase numbers,

2413
03:14:37,480 --> 03:14:43,080
but I do not see special characters.

2414
03:14:43,080 --> 03:14:46,320
So anything that is not in
the range of will be replaced.

2415
03:14:46,560 --> 03:14:56,040
Yes. Yes.

2416
03:14:56,040 --> 03:14:58,720
And you can sit and do the same

2417
03:14:58,720 --> 03:15:02,040
major number and you see, not this.

2418
03:15:02,040 --> 03:15:05,560
This means the range is.

2419
03:15:05,560 --> 03:15:08,040
And you can also specify the

2420
03:15:09,520 --> 03:15:11,520
start and the ending of a string

2421
03:15:13,040 --> 03:15:15,720
word, not a word, a boundary,

2422
03:15:16,400 --> 03:15:18,920
a scaled special characters.

2423
03:15:19,400 --> 03:15:32,440
You can remove tabs, for example, this

2424
03:15:32,480 --> 03:15:36,960
these are also very helpful.

2425
03:15:36,960 --> 03:15:39,680
For example, if you write

2426
03:15:40,920 --> 03:15:43,680
a and then a plus sign,

2427
03:15:44,560 --> 03:15:50,200
it will highlight only backwards,
which D means digit

2428
03:15:50,560 --> 03:15:54,440
any number 0123456789.

2429
03:15:55,400 --> 03:16:00,000
So a and plus means if there are zero,

2430
03:16:00,000 --> 03:16:05,040
if there are one or more,
if there are one or more

2431
03:16:06,240 --> 03:16:09,720
a is are present, then them.

2432
03:16:09,840 --> 03:16:15,240
So it will highlight all of them.

2433
03:16:15,240 --> 03:16:19,320
And a and curly bracket means a

2434
03:16:20,920 --> 03:16:24,480
and curly bracket and let's say for means

2435
03:16:25,160 --> 03:16:31,560
if there are four A's together,
if there are four A's

2436
03:16:32,200 --> 03:16:36,120
and if they are present together,
then highlight them.

2437
03:16:36,120 --> 03:16:41,880
So for example,
if I put 1 to 3 for it to be highlight,

2438
03:16:42,720 --> 03:16:47,240
I can specify say if there are aa2

2439
03:16:47,240 --> 03:16:49,640
is are present together then highlighted.

2440
03:16:50,280 --> 03:16:53,080
So the latter and then curly brackets

2441
03:16:53,640 --> 03:17:00,200
and then the number
how many you want to see together.

2442
03:17:00,200 --> 03:17:04,800
You can also specify eight brackets
one and three between one and three

2443
03:17:05,040 --> 03:17:06,480
separate out.

2444
03:17:06,480 --> 03:17:10,400
I think we I have, I never showed this

2445
03:17:10,400 --> 03:17:13,960
regular expression
in this much detail to any batch.

2446
03:17:14,520 --> 03:17:15,760
You are the first ones.

2447
03:17:15,760 --> 03:17:19,880
I hardly show them how to that range thing
and that's it.

2448
03:17:20,480 --> 03:17:22,680
But I think it's not that hard.

2449
03:17:22,920 --> 03:17:25,760
And if you want to try it, try out more.

2450
03:17:25,800 --> 03:17:27,240
It is also not that

2451
03:17:28,600 --> 03:17:28,920
hard.

2452
03:17:28,920 --> 03:17:30,720
I think it's simple.

2453
03:17:30,720 --> 03:17:32,880
And again,
you don't need to memorize this.

2454
03:17:33,640 --> 03:17:37,920
You don't need to memorize this
so you can open the cheat sheet here.

2455
03:17:38,280 --> 03:17:41,000
You can read the regular expressions here,

2456
03:17:41,280 --> 03:17:44,120
all the documentation, you can test it,

2457
03:17:44,120 --> 03:17:49,440
and then you're going to use it.

2458
03:17:49,440 --> 03:17:51,840
So and I don't think so.

2459
03:17:51,840 --> 03:17:54,120
You still understand the power

2460
03:17:54,120 --> 03:17:57,440
that you are getting with the help of,
these regular expressions.

2461
03:17:58,080 --> 03:18:02,400
Now, you will be able to process
almost any kind of text

2462
03:18:03,520 --> 03:18:18,360
with the help of your Java programs.

2463
03:18:18,360 --> 03:18:28,240
Okay.

2464
03:18:28,240 --> 03:18:29,080
Okay.

2465
03:18:29,520 --> 03:18:34,080
If any of this is not clear
or if there are any questions, please ask.

2466
03:18:34,240 --> 03:18:49,120
Otherwise
we will move to the next example.

2467
03:18:49,120 --> 03:19:03,240
Okay, Let me show you more matters.

2468
03:19:03,240 --> 03:19:06,440
Yes, the regular expressions
like short shorters.

2469
03:19:06,960 --> 03:19:09,920
Imagine if you do not have
regular expression,

2470
03:19:09,920 --> 03:19:13,320
you might have to write
a lot of false conditions.

2471
03:19:13,320 --> 03:19:15,320
You might have the right lobes

2472
03:19:15,320 --> 03:19:17,960
if you want to remove something
or filter out something.

2473
03:19:18,320 --> 03:19:23,160
So it can be very challenging at times
if you don't use regular expression.

2474
03:19:23,160 --> 03:19:25,040
It's just very simple thing and it

2475
03:19:26,600 --> 03:19:31,920
is looking good.

2476
03:19:31,920 --> 03:19:34,920
Let me let me give you a task and

2477
03:19:36,520 --> 03:19:38,160
so that I know if you have understood

2478
03:19:38,160 --> 03:19:40,200
better in our property

2479
03:19:42,600 --> 03:19:43,520
and then we will continue

2480
03:19:43,520 --> 03:19:51,480
from there.

2481
03:19:51,480 --> 03:19:54,240
Let's say I am getting

2482
03:19:56,920 --> 03:20:00,400
a string from the user

2483
03:20:08,520 --> 03:20:12,400
and let's say this string contains

2484
03:20:35,320 --> 03:20:37,400
okay, let's say someone entered

2485
03:20:37,840 --> 03:20:40,880
or someone has entered this information

2486
03:20:40,880 --> 03:20:44,480
from the website
and you get this output like this

2487
03:20:45,080 --> 03:20:47,880
and your menu says, Hey,
someone is entering garbage.

2488
03:20:48,360 --> 03:20:52,240
I do not want this thing in the text,

2489
03:20:52,800 --> 03:20:55,720
but I do java code to remove this part

2490
03:20:56,440 --> 03:20:59,000
from this string.

2491
03:20:59,000 --> 03:21:02,400
And you have to write a program
for right, write one.

2492
03:21:02,400 --> 03:21:03,640
So that

2493
03:21:04,400 --> 03:21:06,200
look, remember question mark.

2494
03:21:06,200 --> 03:21:08,280
It's a valid injection.

2495
03:21:08,640 --> 03:21:11,360
Dot is also good rest. Also looks good.

2496
03:21:11,360 --> 03:21:30,480
But this here,
this is what we want to remove.

2497
03:21:30,480 --> 03:21:30,640
Yeah.

2498
03:21:30,640 --> 03:21:37,000
Let me send you here.

2499
03:21:37,000 --> 03:21:39,400
Well, what is the name of this movie?

2500
03:21:39,400 --> 03:21:42,880
Movie anywhere?

2501
03:21:42,880 --> 03:21:43,400
No, no, no.

2502
03:21:43,400 --> 03:21:45,560
The one from which you have shared to me.

2503
03:21:45,560 --> 03:21:47,480
I think it's a very Friday or.

2504
03:21:47,480 --> 03:21:50,680
Okay, Yeah,
this one is a very funny one, right?

2505
03:21:50,720 --> 03:21:51,560
I'm not going

2506
03:21:59,840 --> 03:22:05,720
type to want.

2507
03:22:05,720 --> 03:22:14,760
Oh, everyone is there to ask the player.

2508
03:22:14,760 --> 03:22:17,200
Oh, perfect.

2509
03:22:17,320 --> 03:22:18,720
If you need an

2510
03:23:26,040 --> 03:23:29,560
did you want us to manually for them
or you ask me

2511
03:23:29,560 --> 03:23:35,000
whichever way you like,
whichever way you like.

2512
03:23:35,480 --> 03:23:38,320
I can see from the ASCII
and the right rate

2513
03:23:38,320 --> 03:23:41,160
hash and percentage

2514
03:23:41,400 --> 03:23:42,880
C and three eight

2515
03:23:42,880 --> 03:23:52,040
hash and percentage.

2516
03:23:52,040 --> 03:23:54,800
I think if you go with the ask, it will
it will become hard

2517
03:23:56,000 --> 03:23:59,440
because remember,
you still want to have a period

2518
03:23:59,440 --> 03:24:04,560
and question mark.

2519
03:24:04,560 --> 03:24:12,520
Oh, it was the name of the movie.

2520
03:24:12,520 --> 03:24:15,760
I thought you were talking to someone

2521
03:24:36,680 --> 03:24:39,200
1996.

2522
03:24:39,240 --> 03:25:25,160
It would screwed.

2523
03:25:25,160 --> 03:25:40,520
Okay, is there anyone
who is unable to do this task?

2524
03:25:40,520 --> 03:25:43,960
Why mine is removing this special
I don't know what expression

2525
03:25:43,960 --> 03:26:04,320
you have written.

2526
03:26:04,320 --> 03:26:09,720
Okay,
so you get this is this was very simple.

2527
03:26:09,720 --> 03:26:12,680
Replace all what we want to replace.

2528
03:26:13,960 --> 03:26:15,640
We want to replace the error

2529
03:26:15,640 --> 03:26:19,440
rate, the hash

2530
03:26:20,720 --> 03:26:22,880
and then the percentage.

2531
03:26:22,880 --> 03:26:23,600
All right?

2532
03:26:24,240 --> 03:26:26,400
And then like this,

2533
03:26:26,400 --> 03:26:32,800
okay,

2534
03:26:32,800 --> 03:26:38,640
turns.

2535
03:26:38,640 --> 03:26:46,320
Okay, one more thing.

2536
03:26:46,320 --> 03:26:52,080
What if the string is like this?

2537
03:26:52,080 --> 03:26:54,720
Or maybe I can give you that as homework

2538
03:26:59,280 --> 03:27:01,560
did not use this brackets and it worked.

2539
03:27:01,960 --> 03:27:02,320
Oh yeah.

2540
03:27:02,320 --> 03:27:05,400
So regular
expression is just like programing.

2541
03:27:06,000 --> 03:27:19,800
Same problem can be solved
in many different ways.

2542
03:27:19,800 --> 03:27:20,960
Let me see.

2543
03:27:21,600 --> 03:27:25,720
I guess our next method is the split

2544
03:27:25,720 --> 03:27:54,080
method.

2545
03:27:54,080 --> 03:27:57,840
Okay, so let's say

2546
03:27:59,400 --> 03:28:01,840
this is the this is a string.

2547
03:28:03,120 --> 03:28:06,840
And from this, a string.

2548
03:28:06,840 --> 03:28:08,920
Let me make it even simpler.

2549
03:28:08,920 --> 03:28:09,280
I think.

2550
03:28:09,280 --> 03:28:12,120
Let's say you have just this idea.

2551
03:28:12,320 --> 03:28:14,280
Are you good?

2552
03:28:14,280 --> 03:28:16,440
Is this paragraph

2553
03:28:16,760 --> 03:28:18,840
it contains, let's say, multiple

2554
03:28:20,520 --> 03:28:22,080
sentences

2555
03:28:22,440 --> 03:28:25,000
and you want to split

2556
03:28:25,000 --> 03:28:30,720
you want to split these the sentences.

2557
03:28:30,720 --> 03:28:31,920
That is also possible.

2558
03:28:33,480 --> 03:28:37,320
For example, there is a method

2559
03:28:40,440 --> 03:28:45,240
and the name of the method
is called split.

2560
03:28:46,160 --> 03:28:48,720
And remember again

2561
03:28:49,480 --> 03:28:50,600
the split method,

2562
03:28:50,600 --> 03:28:53,360
it also takes a regular expression.

2563
03:28:53,840 --> 03:29:02,160
How can I confirm
if it takes the regular expression?

2564
03:29:02,160 --> 03:29:03,240
How do I know the matter

2565
03:29:03,240 --> 03:29:06,080
takes the regular expression
under an almost normal string?

2566
03:29:07,320 --> 03:29:09,400
Yes You can look it from here.

2567
03:29:09,400 --> 03:29:13,400
Or even better way
is to read the documentation.

2568
03:29:14,160 --> 03:29:16,440
If I want to know how this method works,

2569
03:29:17,600 --> 03:29:19,920
I can however my mouse over the method

2570
03:29:26,040 --> 03:29:27,080
like this

2571
03:29:27,840 --> 03:29:30,160
and I can read

2572
03:29:30,160 --> 03:29:32,880
the explanation of all this by example.

2573
03:29:32,880 --> 03:29:36,880
If there splits this string around
the matches.

2574
03:29:37,040 --> 03:29:39,720
Also given regular expression,

2575
03:29:40,600 --> 03:29:45,280
this method works if you are invoking
the two arguments method

2576
03:29:46,000 --> 03:29:51,160
and then it shows you examples as that.

2577
03:29:51,160 --> 03:29:51,840
So now

2578
03:29:53,400 --> 03:29:56,000
from this spring

2579
03:29:56,000 --> 03:29:58,280
I am trying to split this string

2580
03:29:59,400 --> 03:30:05,400
based on the dot.

2581
03:30:05,400 --> 03:30:09,600
If I do that, how many strings?

2582
03:30:09,600 --> 03:30:15,000
As a result of this I will be getting two

2583
03:30:16,560 --> 03:30:21,360
and depending upon this string
I might get the three as well.

2584
03:30:21,360 --> 03:30:24,480
Right.

2585
03:30:24,480 --> 03:30:30,440
For example,
if I have this, how many strings

2586
03:30:30,440 --> 03:30:34,960
I will be getting now as a result?

2587
03:30:34,960 --> 03:30:35,920
Three.

2588
03:30:36,840 --> 03:30:39,080
So what type of variable I should create

2589
03:30:39,400 --> 03:30:41,400
to store the results

2590
03:30:42,520 --> 03:30:44,720
of this split method?

2591
03:30:44,720 --> 03:30:46,040
Exactly.

2592
03:30:46,040 --> 03:30:51,600
We need an array
because depending upon the operation

2593
03:30:51,600 --> 03:30:55,200
that we are performing, we might get

2594
03:30:56,720 --> 03:30:57,640
three strings.

2595
03:30:57,640 --> 03:31:00,400
As a result, we might get 10,000 strings.

2596
03:31:00,400 --> 03:31:02,400
As a result, we might get five strings.

2597
03:31:02,400 --> 03:31:07,920
As a result, it will split and will create
that many individual strings.

2598
03:31:08,240 --> 03:31:11,080
So here the return type or

2599
03:31:11,080 --> 03:31:14,600
the output of this
method is going to be an array

2600
03:31:18,440 --> 03:31:19,480
of strings.

2601
03:31:19,480 --> 03:31:22,240
Does it make sense why the return type

2602
03:31:22,240 --> 03:31:25,960
is an array of strings
instead of individual string or?

2603
03:31:25,960 --> 03:31:41,160
Maybe something else.

2604
03:31:41,160 --> 03:31:41,640
Everyone.

2605
03:31:41,640 --> 03:31:53,880
Is it clear why split
method is going to return an array?

2606
03:31:53,880 --> 03:32:00,200
So if I am splitting based on the dot,
how many?

2607
03:32:00,720 --> 03:32:01,720
How many what?

2608
03:32:01,720 --> 03:32:04,920
What should be the size of this? Edit

2609
03:32:04,920 --> 03:32:08,000
What should be the size of this area?

2610
03:32:08,000 --> 03:32:12,880
Three So if I say SDR dart length,

2611
03:32:14,520 --> 03:32:22,080
I should be getting three right?

2612
03:32:22,080 --> 03:32:24,280
I do get three.

2613
03:32:24,280 --> 03:32:27,560
And from this add a

2614
03:32:27,840 --> 03:32:31,280
from this SDR array.

2615
03:32:32,320 --> 03:32:36,000
If I put the element at index number zero,
what do you expect?

2616
03:32:36,000 --> 03:32:38,360
What should I get or what will I get

2617
03:32:45,440 --> 03:32:48,320
the first sentence

2618
03:32:49,280 --> 03:32:54,720
this block.

2619
03:32:54,720 --> 03:32:55,160
All righty.

2620
03:32:55,160 --> 03:32:58,880
At how I remember this dart is gone.

2621
03:33:00,360 --> 03:33:02,880
Whatever we are using

2622
03:33:02,880 --> 03:33:06,360
to spare something,
that thing is not included in the output.

2623
03:33:07,160 --> 03:33:10,560
And if I put two here

2624
03:33:11,880 --> 03:33:21,000
or the thing what output I will get,
I am bad.

2625
03:33:22,680 --> 03:33:26,200
The last sentence

2626
03:33:27,400 --> 03:33:28,320
I am right.

2627
03:33:28,320 --> 03:33:29,760
Hmm. I'm getting at it.

2628
03:33:29,760 --> 03:33:31,800
Getting a space here.

2629
03:33:31,800 --> 03:33:34,560
Is it possible in a string to remove

2630
03:33:34,920 --> 03:33:39,240
extra spaces that for example,
I'm getting one extra space here?

2631
03:33:40,560 --> 03:33:42,240
Yes. So.

2632
03:33:42,240 --> 03:33:45,320
And can I use method chaining for example?

2633
03:33:45,320 --> 03:33:49,680
Can I simply write not and can say trim?

2634
03:33:50,160 --> 03:33:54,240
Yes. So prim will remove the spaces

2635
03:33:54,360 --> 03:33:57,200
which we are getting.

2636
03:33:57,480 --> 03:33:59,480
How did you see what SDF

2637
03:33:59,480 --> 03:34:02,400
splitting does that detail page?

2638
03:34:02,560 --> 03:34:08,000
So for every if you want to know
what that method is for,

2639
03:34:08,400 --> 03:34:11,440
you can hover your mouse
over the name of that matter

2640
03:34:17,280 --> 03:34:18,120
and then it will show

2641
03:34:18,120 --> 03:34:24,640
you will be explanation.

2642
03:34:24,640 --> 03:34:27,080
It's a very bad thing.

2643
03:34:27,080 --> 03:34:31,760
Julia I think you might also have
to reinstall the windows

2644
03:34:32,040 --> 03:34:35,920
if it was doing some critical updates
and if you stop it

2645
03:34:35,920 --> 03:34:40,680
in the middle of the process,
you might have to reinstall it.

2646
03:34:40,800 --> 03:34:51,280
It might corrupt
computer operating system.

2647
03:34:51,280 --> 03:34:53,640
Okay, yeah, you can remove the tree.

2648
03:34:54,280 --> 03:34:58,440
So line

2649
03:34:58,440 --> 03:35:03,760
it will remove the extra space
that we were getting before I am driving.

2650
03:35:04,240 --> 03:35:07,120
So for example,
I print this exact same thing

2651
03:35:08,520 --> 03:35:10,600
without rain.

2652
03:35:10,600 --> 03:35:16,320
You will notice
that there is an extra space coming.

2653
03:35:16,320 --> 03:35:20,400
We see there is this extra space
before the start because

2654
03:35:21,440 --> 03:35:22,960
this is my sentence.

2655
03:35:22,960 --> 03:35:24,960
After the docked.

2656
03:35:24,960 --> 03:35:28,360
So when we split based on that,
sometimes we might get extra

2657
03:35:28,360 --> 03:35:33,080
things that we don't like
and then you can remove that.

2658
03:35:33,080 --> 03:35:35,520
Okay, how can we split the words?

2659
03:35:35,920 --> 03:35:39,680
Let's say this time from this sentence,
I want individual words

2660
03:35:40,560 --> 03:35:46,840
based on what I should split.

2661
03:35:46,840 --> 03:35:49,880
Exactly. If you split

2662
03:35:50,960 --> 03:35:53,640
based on this space,

2663
03:35:53,640 --> 03:35:56,280
you will be actually you have

2664
03:35:56,280 --> 03:35:59,800
you have made me tell the answer
of one of your homeworks.

2665
03:35:59,800 --> 03:36:05,120
But that's fine.

2666
03:36:05,120 --> 03:36:08,280
It was one of your homeworks.

2667
03:36:08,280 --> 03:36:12,480
So instead of specifying the not

2668
03:36:13,120 --> 03:36:15,600
what you want me
to tell the homework number as well,

2669
03:36:17,520 --> 03:36:20,240
you can specify a space

2670
03:36:20,760 --> 03:36:25,200
here.

2671
03:36:25,200 --> 03:36:27,600
Okay. Now tell me, what do you think?

2672
03:36:27,600 --> 03:36:30,600
What will be the length of the 80

2673
03:36:32,160 --> 03:36:36,480
this time?

2674
03:36:36,480 --> 03:36:40,640
So one, two, three, four,

2675
03:36:40,640 --> 03:36:44,760
five, six, seven, eight,
nine, ten, 11, 1112.

2676
03:36:44,760 --> 03:36:48,880
Something like this.

2677
03:36:48,880 --> 03:36:52,760
We are getting ten, one, two, three, four.

2678
03:36:54,000 --> 03:36:55,920
This is five.

2679
03:36:56,160 --> 03:36:58,560
You and I,

2680
03:36:58,560 --> 03:37:02,720
They will be treated one word
because there is no space in between.

2681
03:37:03,480 --> 03:37:06,240
Next slide ten, not 11

2682
03:37:06,240 --> 03:37:08,800
is this part clear
why we are getting ten, not 11?

2683
03:37:09,000 --> 03:37:11,400
Because if you don't, I

2684
03:37:11,400 --> 03:37:14,920
it will be treated as one single word
because there is no space.

2685
03:37:14,920 --> 03:37:24,360
We are splitting based on this space.

2686
03:37:24,360 --> 03:37:24,800
Okay,

2687
03:37:25,800 --> 03:37:28,280
So if I

2688
03:37:28,280 --> 03:37:32,160
say SD R and zero, what do you think?

2689
03:37:32,160 --> 03:37:38,840
What time is it? Hi.

2690
03:37:39,120 --> 03:37:41,320
Yes, why not?

2691
03:37:41,320 --> 03:37:42,680
Give me one second

2692
03:37:43,920 --> 03:37:47,240
and. If I say, then

2693
03:37:49,080 --> 03:37:54,560
what will happen?

2694
03:37:54,560 --> 03:38:02,240
I'm saying ten and then SVR ten. Why?

2695
03:38:02,440 --> 03:38:05,320
Why are you saying And

2696
03:38:05,480 --> 03:38:07,600
why are you saying M?

2697
03:38:07,600 --> 03:38:11,480
This is 1234.

2698
03:38:12,200 --> 03:38:14,200
This is 5:08 a.m.

2699
03:38:14,200 --> 03:38:16,680
was six Exactly.

2700
03:38:16,680 --> 03:38:19,080
We will be getting an ad of y error

2701
03:38:20,040 --> 03:38:22,680
because indexes are always

2702
03:38:22,680 --> 03:38:24,680
one less than the land.

2703
03:38:25,680 --> 03:38:26,880
Do not forget this.

2704
03:38:26,880 --> 03:38:29,320
A lot of the times you make this mistake,

2705
03:38:29,320 --> 03:38:33,880
indexes are always one
less than the length lent is done.

2706
03:38:33,880 --> 03:38:36,280
That means at max we can go nine.

2707
03:38:37,520 --> 03:38:40,000
So very common mistake
that you are making these days.

2708
03:38:41,800 --> 03:38:43,920
So now I will be getting driving

2709
03:38:48,840 --> 03:38:52,920
o k and if I get this high

2710
03:38:52,960 --> 03:38:58,960
there, let's say
you want to skip this dot as well.

2711
03:38:58,960 --> 03:39:02,360
Whether it's a space

2712
03:39:03,320 --> 03:39:06,000
or a dot, I don't care.

2713
03:39:06,000 --> 03:39:08,000
I want to split based on that.

2714
03:39:08,000 --> 03:39:09,240
So let's try this.

2715
03:39:09,240 --> 03:39:12,600
I think it should work fine.

2716
03:39:12,600 --> 03:39:15,120
You can specify the

2717
03:39:20,240 --> 03:39:22,800
cloudy s for the space

2718
03:39:22,800 --> 03:39:26,920
and you can specify the not as well.

2719
03:39:26,920 --> 03:39:30,240
By this,
I think it should work fine, otherwise

2720
03:39:30,280 --> 03:39:36,440
we have to figure it out.

2721
03:39:36,440 --> 03:39:39,600
Know.

2722
03:39:39,600 --> 03:39:44,880
Let's see if we have this

2723
03:39:51,600 --> 03:39:54,120
not to split

2724
03:39:54,120 --> 03:39:56,360
based on this

2725
03:39:57,960 --> 03:40:00,680
in our style. This

2726
03:40:07,920 --> 03:40:12,280
this time it work.

2727
03:40:12,280 --> 03:40:12,680
Yeah.

2728
03:40:12,840 --> 03:40:17,560
So this time we are getting 12.

2729
03:40:17,560 --> 03:40:19,520
We are getting 12 hours.

2730
03:40:19,520 --> 03:40:21,640
So one is high

2731
03:40:22,920 --> 03:40:24,720
then we are getting bigger.

2732
03:40:24,720 --> 03:40:27,720
Then how then are then you

2733
03:40:29,040 --> 03:40:32,600
then I am then again.

2734
03:40:32,600 --> 03:40:33,320
Good.

2735
03:40:33,320 --> 03:40:36,640
And then this space here and then I.

2736
03:40:36,640 --> 03:40:38,360
And I'm driving.

2737
03:40:38,360 --> 03:40:41,240
So previously this you

2738
03:40:41,760 --> 03:40:44,840
and I, it was treated as a single word.

2739
03:40:45,120 --> 03:40:52,840
Me comment this for a simple.

2740
03:40:52,840 --> 03:40:56,440
So previously
when we were splitting based on the

2741
03:40:57,480 --> 03:41:00,040
based on only the space

2742
03:41:00,040 --> 03:41:02,440
we were getting

2743
03:41:03,440 --> 03:41:06,920
ten words
and why we were getting worse and worse

2744
03:41:06,920 --> 03:41:11,520
because it was treating this high
as one word there and another one

2745
03:41:12,600 --> 03:41:14,880
this tired fourth and fifth.

2746
03:41:14,880 --> 03:41:16,880
So if we try to bring

2747
03:41:20,920 --> 03:41:21,480
in the word

2748
03:41:21,480 --> 03:41:24,960
number five,
you will see that, do you not?

2749
03:41:24,960 --> 03:41:30,280
I would walk into 20234.

2750
03:41:30,280 --> 03:41:37,160
Sorry, it was four.

2751
03:41:37,160 --> 03:41:41,280
So you and not I.

2752
03:41:41,280 --> 03:41:43,440
They were treated as single word.

2753
03:41:44,320 --> 03:41:46,680
Then what we did, we

2754
03:41:47,760 --> 03:41:49,000
wrote an explainer.

2755
03:41:49,000 --> 03:41:54,200
We wrote a regular expression
that whether it's a space

2756
03:41:55,080 --> 03:41:58,000
or it's a dog, which

2757
03:41:58,000 --> 03:42:01,880
whichever of these is present,
I want to split based on that.

2758
03:42:02,400 --> 03:42:04,440
So we used that

2759
03:42:05,400 --> 03:42:12,520
as the criteria to split.

2760
03:42:12,520 --> 03:42:18,120
You was also separated out from this.

2761
03:42:18,120 --> 03:42:19,640
I is this part clear?

2762
03:42:19,640 --> 03:42:22,920
What what, what,
what is happening when I specify

2763
03:42:22,920 --> 03:42:25,840
a dot as well as a space

2764
03:42:26,480 --> 03:42:30,000
as the criteria to split?

2765
03:42:30,000 --> 03:42:34,440
Now, whether it sees a space
or a dog, it will split.

2766
03:42:35,640 --> 03:42:37,080
And you can also do this.

2767
03:42:37,080 --> 03:42:40,560
You can basically write a loop
together, get

2768
03:42:40,720 --> 03:42:42,760
see all of the

2769
03:42:43,800 --> 03:42:45,440
all of the letters that you are getting.

2770
03:42:45,440 --> 03:42:46,880
So for

2771
03:42:47,640 --> 03:42:50,240
String S

2772
03:42:50,280 --> 03:42:52,680
in SDR and remember, I'm

2773
03:42:52,680 --> 03:42:55,640
using an enhanced for loop

2774
03:42:56,600 --> 03:42:59,080
and why I'm able to use an enhanced model

2775
03:42:59,080 --> 03:43:06,080
because it's an addy.

2776
03:43:06,080 --> 03:43:16,240
Oh, I do not pretend.

2777
03:43:16,240 --> 03:43:20,680
So now I see all of the words here.

2778
03:43:20,680 --> 03:43:23,440
I'm getting an extra space as well,
which can be more busy.

2779
03:43:24,600 --> 03:43:27,160
So this is how this works.

2780
03:43:27,160 --> 03:43:28,760
Basically what speed does?

2781
03:43:28,760 --> 03:43:29,920
Let me show you more examples.

2782
03:43:29,920 --> 03:43:39,680
Maybe you are still confused.

2783
03:43:39,680 --> 03:43:43,440
If there is someone who is following me,
let me know once you are done typing

2784
03:43:43,440 --> 03:44:00,480
or if you want to form.

2785
03:44:00,480 --> 03:44:04,600
So let's say for example,

2786
03:44:04,600 --> 03:44:08,160
you get some kind of
text and let's say every word

2787
03:44:09,360 --> 03:44:12,360
is separated by a hash symbol

2788
03:44:15,440 --> 03:44:20,360
and try to generalize it
to make it simpler.

2789
03:44:21,720 --> 03:44:23,640
So this is the string that you getting.

2790
03:44:23,640 --> 03:44:28,080
For example, every word is a separated

2791
03:44:28,440 --> 03:44:32,000
by a dash, and now your task is

2792
03:44:32,000 --> 03:44:35,880
you want to see you want to get rid
of the individual words.

2793
03:44:36,800 --> 03:44:40,040
So tell me which method
you will use to get the individual words

2794
03:44:40,040 --> 03:44:42,360
out of this string

2795
03:44:49,920 --> 03:44:51,600
Split method.

2796
03:44:51,600 --> 03:44:53,640
You don't need to replace it first.

2797
03:44:53,640 --> 03:44:56,360
You don't need to replace it first.

2798
03:44:56,360 --> 03:44:59,160
You can directly use the splitting.

2799
03:44:59,160 --> 03:45:01,040
It expects you.

2800
03:45:01,040 --> 03:45:04,040
You can
you can provide any regular expressions.

2801
03:45:04,040 --> 03:45:13,720
So for example,
you can write an array. SDR

2802
03:45:19,080 --> 03:45:22,280
and then you can say SDR or SPLIT

2803
03:45:23,200 --> 03:45:26,680
based on what I should split

2804
03:45:29,280 --> 03:45:30,160
if I want to go

2805
03:45:30,160 --> 03:45:34,120
to the individual letters
based on what I should split

2806
03:45:38,040 --> 03:45:40,120
exactly.

2807
03:45:40,720 --> 03:45:42,080
Oh my God, this hash

2808
03:45:42,080 --> 03:45:45,840
is again causing problems.

2809
03:45:45,840 --> 03:45:50,920
Okay,

2810
03:45:50,920 --> 03:45:54,160
so I will be getting an array back

2811
03:45:56,400 --> 03:45:59,400
and what will be the length of that area?

2812
03:45:59,400 --> 03:46:02,400
I will be getting an array of strings

2813
03:46:03,160 --> 03:46:07,080
and what will be the length of that data.

2814
03:46:07,080 --> 03:46:10,920
So we will get one, two, three, four

2815
03:46:10,920 --> 03:46:15,120
and five.

2816
03:46:15,120 --> 03:46:15,600
Okay.

2817
03:46:16,000 --> 03:46:20,840
And from that area,
if I bring print, print, print, print,

2818
03:46:20,840 --> 03:46:23,960
if I say SDR, here are

2819
03:46:24,960 --> 03:46:37,000
one productivity.

2820
03:46:37,000 --> 03:46:39,960
I got a dear

2821
03:46:42,640 --> 03:46:44,880
remember indexes, they start from zero.

2822
03:46:46,360 --> 03:46:48,760
So is this split method clear?

2823
03:46:48,760 --> 03:46:53,520
If there are a lot
of paragraphs, sentences

2824
03:46:54,000 --> 03:46:58,120
and if you want to split that big
the string,

2825
03:46:58,720 --> 03:47:02,160
maybe you want to go to the individual
sentences out of that

2826
03:47:02,160 --> 03:47:05,040
and maybe you want to get individual words
out of that.

2827
03:47:05,400 --> 03:47:08,120
You can also go to individual characters
as well.

2828
03:47:08,760 --> 03:47:11,880
If the words separated by space or hash

2829
03:47:11,880 --> 03:47:15,200
symbol or dog
or star symbol, whatever is the

2830
03:47:16,320 --> 03:47:19,480
character
based on which they are separated,

2831
03:47:19,480 --> 03:47:23,560
just provide that character inside this
method as the argument.

2832
03:47:24,160 --> 03:47:27,040
It will split the words
and it will give you the results

2833
03:47:27,040 --> 03:47:30,600
back in the form of an adding.

2834
03:47:30,600 --> 03:47:39,920
If you have questions, please ask.

2835
03:47:39,920 --> 03:47:42,360
Can you put a single space
between all words?

2836
03:47:42,360 --> 03:47:56,640
Yeah, we can.

2837
03:47:56,640 --> 03:48:00,240
Like for example, let me copy this

2838
03:48:01,520 --> 03:48:03,000
and let me put it here.

2839
03:48:03,000 --> 03:48:06,840
Let's say
the words are separated by a space

2840
03:48:06,840 --> 03:48:10,600
instead of hash.

2841
03:48:10,600 --> 03:48:13,480
So this time, based on what I will split

2842
03:48:21,120 --> 03:48:22,720
based on the space.

2843
03:48:22,720 --> 03:48:23,000
Right.

2844
03:48:23,000 --> 03:48:27,080
And there are multiple ways to specify
a space you can directly put it like this

2845
03:48:28,240 --> 03:48:30,200
or you can use two backward slash slashes.

2846
03:48:30,200 --> 03:48:41,600
Then s0i for this

2847
03:48:43,680 --> 03:48:45,360
no spaces or any extra thing.

2848
03:48:45,360 --> 03:48:48,440
Otherwise you will get going at it.

2849
03:48:48,440 --> 03:48:50,880
I put an extra space here.

2850
03:48:50,880 --> 03:48:54,680
So for double backward slash s
it also means space.

2851
03:48:55,320 --> 03:49:00,360
If you if you find it hard to remember,
you can directly put a space like this

2852
03:49:04,120 --> 03:49:05,680
the same upward.

2853
03:49:05,680 --> 03:49:10,320
So this is how you can split
based on just any character

2854
03:49:10,440 --> 03:49:14,160
or any anything that you have

2855
03:49:16,920 --> 03:49:17,280
would be

2856
03:49:17,280 --> 03:49:21,000
interesting
to try out the enhanced for loop sprint.

2857
03:49:21,000 --> 03:49:25,200
All the added added element are yes,
I think this is what we will be learning

2858
03:49:25,200 --> 03:49:26,040
next.

2859
03:49:26,520 --> 03:49:30,640
I think this is the next method

2860
03:49:32,600 --> 03:49:33,640
for non dark.

2861
03:49:33,640 --> 03:49:35,720
It is not here, but mostly

2862
03:49:46,920 --> 03:49:49,640
going to show you that fact.

2863
03:49:50,200 --> 03:49:54,800
There is a method for that as well.

2864
03:49:54,800 --> 03:49:56,120
And there are more.

2865
03:49:56,120 --> 03:49:56,800
One more thing.

2866
03:49:56,800 --> 03:50:01,720
I'm not going over all the methods which
are present inside this string class.

2867
03:50:01,960 --> 03:50:06,360
There are a lot I have just tried
to go over the most important ones.

2868
03:50:06,600 --> 03:50:10,440
There are more
So before you try to write custom logic

2869
03:50:10,440 --> 03:50:13,680
for any of your tasks, try
look for the method.

2870
03:50:13,720 --> 03:50:18,000
Maybe there is already a method for that.

2871
03:50:18,000 --> 03:50:19,800
The thing that you are trying to do.

2872
03:50:21,200 --> 03:50:22,280
So let's say

2873
03:50:22,280 --> 03:50:24,720
there is this string

2874
03:50:35,760 --> 03:50:37,440
and let's say

2875
03:50:37,440 --> 03:50:40,640
you want to write an enhanced

2876
03:50:40,640 --> 03:50:44,240
for to go over all the elements

2877
03:50:45,320 --> 03:50:47,360
of this string.

2878
03:50:47,520 --> 03:50:51,680
For some reason you just like
the first thing that you have to do is

2879
03:50:51,720 --> 03:50:57,960
you have to convert this string
into an array of characters.

2880
03:50:58,760 --> 03:50:59,840
And it's very simple.

2881
03:50:59,840 --> 03:51:02,320
We we have a method for that.

2882
03:51:02,320 --> 03:51:04,720
So first you will be converting

2883
03:51:05,880 --> 03:51:07,280
this a string.

2884
03:51:07,280 --> 03:51:09,280
Nafisa This is how you can do it.

2885
03:51:09,280 --> 03:51:14,400
Stick on the question
so you can have an array of characters

2886
03:51:18,160 --> 03:51:20,120
and you can call this method

2887
03:51:20,120 --> 03:51:24,400
string dog tool jar. Addy

2888
03:51:25,800 --> 03:51:28,320
This booth jar area.

2889
03:51:28,320 --> 03:51:30,960
It will convert this string

2890
03:51:30,960 --> 03:51:33,840
to an array of characters.

2891
03:51:34,840 --> 03:51:40,200
And then you write and enhance for loop.

2892
03:51:40,200 --> 03:51:43,680
What should I specify
inside the enhanced for loop?

2893
03:51:43,680 --> 03:51:46,320
If I want to go over all the elements

2894
03:51:47,520 --> 03:51:51,480
from this area.

2895
03:51:51,480 --> 03:51:56,520
Cha cha c column here are

2896
03:52:06,000 --> 03:52:08,760
so that's how you can get
individual letters

2897
03:52:08,760 --> 03:52:20,600
from with the help of an enhanced module.

2898
03:52:20,600 --> 03:52:21,960
For example, in the sentence.

2899
03:52:21,960 --> 03:52:23,040
Hi there, how are you.

2900
03:52:23,040 --> 03:52:25,200
How can I there, how are you?

2901
03:52:26,280 --> 03:52:30,000
You can split it
based on the question mark

2902
03:52:31,080 --> 03:52:33,800
and a space and a dart,

2903
03:52:34,560 --> 03:52:37,400
and then you can get the first element

2904
03:52:37,400 --> 03:52:41,840
from this DCT.

2905
03:52:41,840 --> 03:52:45,160
Okay, let's solve some tasks everyone.

2906
03:52:46,080 --> 03:52:46,400
Right.

2907
03:52:46,400 --> 03:53:00,720
Quick word for this first one, okay?

2908
03:53:02,240 --> 03:53:14,480
Yeah, sure, sure.

2909
03:53:14,480 --> 03:53:18,120
Side question Why does the rest
of the world hate Americans?

2910
03:53:18,600 --> 03:53:20,640
I don't think so anyone hurt here.

2911
03:53:20,640 --> 03:53:24,080
Some Americans
especially, I don't think to anyone else

2912
03:53:24,080 --> 03:53:27,640
the people living in this
in their specific nation,

2913
03:53:28,280 --> 03:53:32,240
you might hear top
guys who are making the decisions

2914
03:53:32,240 --> 03:53:36,680
for other countries
or other nations or something like that.

2915
03:53:37,680 --> 03:53:44,960
All immigrants, I don't know.

2916
03:53:44,960 --> 03:53:48,200
I mean, for example,
whoever is controlling that nation,

2917
03:53:49,160 --> 03:53:52,320
they are the ones who are taking
the decisions most of the time.

2918
03:53:52,680 --> 03:53:54,360
I mean, some nations, they are very good.

2919
03:53:54,360 --> 03:53:58,640
They stand
If something goes wrong, for example, in

2920
03:53:59,080 --> 03:54:02,920
I get I guess in France, even if you

2921
03:54:03,960 --> 03:54:07,200
even if you
I mean, almost every other day,

2922
03:54:07,960 --> 03:54:10,240
the people from France, they are in

2923
03:54:11,400 --> 03:54:13,400
some kind of protest against.

2924
03:54:13,400 --> 03:54:18,040
Their government, even if their government
does like small things

2925
03:54:19,400 --> 03:54:22,560
and they don't like it,
they are always standing and

2926
03:54:22,560 --> 03:54:25,200
and speaking about it

2927
03:54:26,680 --> 03:54:30,120
like this is the task

2928
03:54:31,800 --> 03:54:32,160
here.

2929
03:54:32,160 --> 03:54:34,480
People are great everywhere.

2930
03:54:34,480 --> 03:54:43,760
All dawn.

2931
03:54:44,240 --> 03:54:45,920
That's correct.

2932
03:54:46,440 --> 03:54:49,200
So the task is you have to create a string

2933
03:54:49,920 --> 03:54:53,320
and then put some kind
of sentence in industry

2934
03:54:53,880 --> 03:54:55,920
and then you have to get a new string.

2935
03:54:56,640 --> 03:55:06,960
But without spaces.

2936
03:55:06,960 --> 03:55:10,480
So basically this task
is you have to remove the spaces

2937
03:55:11,760 --> 03:55:13,600
from any

2938
03:55:13,600 --> 03:55:46,040
string.

2939
03:55:46,040 --> 03:55:46,840
By the way,

2940
03:55:46,840 --> 03:55:50,040
those who are done with the first one,
you can start working on the second one

2941
03:56:30,000 --> 03:56:32,760
brain has stopped working,

2942
03:56:33,000 --> 03:56:36,720
brain overloaded.

2943
03:56:36,720 --> 03:59:02,040
If you want,
you can solve them as your work.

2944
03:59:02,040 --> 03:59:02,840
Okay,

2945
03:59:04,080 --> 03:59:06,320
These are some of the videos

2946
03:59:06,320 --> 03:59:10,720
that you have to watch before
tomorrow and.

2947
03:59:10,720 --> 03:59:14,000
They might look a little different

2948
03:59:15,600 --> 03:59:17,800
and they might also not

2949
03:59:21,120 --> 03:59:24,600
it's language.

2950
03:59:25,320 --> 03:59:30,880
So everyone I did,

2951
03:59:30,880 --> 03:59:33,760
the people who go me,

2952
03:59:35,040 --> 03:59:41,400
anyone,

2953
03:59:41,400 --> 03:59:47,960
anyone, individual,

2954
03:59:48,440 --> 03:59:50,680
they things about

2955
04:00:16,680 --> 04:00:18,920
these two videos, they are more important

2956
04:00:20,480 --> 04:00:23,800
than the ones that I have shared.

2957
04:00:23,800 --> 04:00:24,720
They are also important.

2958
04:00:24,720 --> 04:00:30,680
But this is this is what we will be
discussing tomorrow.

2959
04:00:30,840 --> 04:00:37,040
Most of the time.

2960
04:00:37,040 --> 04:00:40,080
What about the object class?

2961
04:00:40,320 --> 04:00:42,000
We will keep on using that

2962
04:00:42,000 --> 04:00:44,440
object class
throughout the rest of the course

2963
04:00:45,280 --> 04:00:49,520
for second tasks or just for any B
and easy or any B and easy.

2964
04:00:49,680 --> 04:00:50,440
Yeah.

2965
04:00:50,880 --> 04:00:53,640
Okay.

2966
04:00:53,640 --> 04:00:58,040
Let me also share this slides with you.
